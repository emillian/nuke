import os, sys, re, subprocess, time, datetime, json, argparse, socket, base64
import SimpleHTTPServer, SocketServer
from distutils.spawn import find_executable
from string import Template

def version ():
    major = 0
    minor = 3
    build = 21
    ver = [str(major), str(minor), str(build)]
    return '.'.join(ver)

def create_assets(dst):
    dct = [
        ('index.html', "PCFET0NUWVBFIGh0bWw+CjxodG1sIGxhbmc9ImVuIj4KPGhlYWQ+CiAgICA8bWV0YSBjaGFyc2V0PSJVVEYtOCI+CiAgICA8dGl0bGU+bWFrZSBwcm94eTwvdGl0bGU+CiAgICA8bWV0YSBuYW1lPXZpZXdwb3J0IGNvbnRlbnQ9IndpZHRoPWRldmljZS13aWR0aCwgaW5pdGlhbC1zY2FsZT0xLjAsIG1pbmltdW0tc2NhbGU9MC41IG1heGltdW0tc2NhbGU9MS4wIj4KICAgIDxzY3JpcHQgc3JjPSJ6ZXB0by5taW4uanMiPjwvc2NyaXB0PgogICAgPGxpbmsgcmVsPSJzdHlsZXNoZWV0IiBocmVmPSJzdHlsZS5jc3MiPgo8L2hlYWQ+Cjxib2R5PgogICAgPGRpdiBjbGFzcz0icGciPgogICAgICAgIDxkaXYgaWQ9InByb2dyZXNzIiBjbGFzcz0icHJvZ3Jlc3MiPjwvZGl2PgogICAgICAgIDxoMT5NYWtlIFByb3h5IDxzcGFuIGlkPSJ2ZXJzaW9uIj48L3NwYW4+PC9oMT4KICAgICAgICA8aDI+RkZNUEVHIENvbmZpZ3VyYXRpb248L2gyPgogICAgICAgIDxkaXYgaWQ9Im1haW4iIGNsYXNzPSJtYWluIj48L2Rpdj4KICAgICAgICA8YSBocmVmPSIjbG9hZF9sb2ciIGlkPSJsb2FkX2xvZyIgY2xhc3M9ImxvZy12aWV3Ij5WaWV3IGxvZyBmaWxlPC9hPgogICAgICAgIDxkaXYgY2xhc3M9ImxvZyIgaWQ9ImxvZy1jb250YWluZXIiPgogICAgICAgICAgICA8aDI+Q3VycmVudCBsb2cgZmlsZTwvaDI+CiAgICAgICAgICAgIDxkaXYgaWQ9IndvcmtlcnMiIGNsYXNzPSJ3b3JrZXJzIj48L2Rpdj4KICAgICAgICAgICAgPGRpdiBjbGFzcz0ibG9nLWhlYWRlciI+CiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0ibG9nLWNlbGwgbG9nLXR5cGUiIHRpdGxlPSIiPlRZUEU8L3NwYW4+CiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0ibG9nLWNlbGwgbG9nLXdvcmtlciIgdGl0bGU9IiI+V09SS0VSPC9zcGFuPgogICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9ImxvZy1jZWxsIGxvZy1kZXNjIiB0aXRsZT0iIj5ERVNDUklQVElPTjwvc3Bhbj4KICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSJsb2ctY2VsbCBsb2ctdmFsdWUiIHRpdGxlPSIiPlZBTFVFPC9zcGFuPgogICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9ImxvZy1jZWxsIGxvZy1leHRyYSIgdGl0bGU9IiI+RVhUUkE8L3NwYW4+CiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0ibG9nLWNlbGwgbG9nLXRpbWUiIHRpdGxlPSIiPlRJTUU8L3NwYW4+CiAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICA8ZGl2IGlkPSJsb2ciIGNsYXNzPSJsb2ctY29udGVudCI+TG9hZGluZyAuLi48L2Rpdj4KICAgICAgICA8L2Rpdj4KICAgIDwvZGl2PgogICAgPHNjcmlwdCBzcmM9Im1haW4uanMiPjwvc2NyaXB0Pgo8L2JvZHk+CjwvaHRtbD4="),
        ('style.css', "Ym9keSB7CiAgICBtYXJnaW46IDA7CiAgICBwYWRkaW5nOiAwOwogICAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7CiAgICBmb250LXNpemU6IDE0cHg7Cn0KLnBnIHsKICAgIG1heC13aWR0aDogMTAyNHB4OwogICAgbWFyZ2luOiAwIGF1dG87CiAgICBkaXNwbGF5OiBibG9jazsKfQoubWFpbiB7CiAgICBwYWRkaW5nOiAxMHB4Owp9Ci5yb3cgewogICAgZGlzcGxheTogYmxvY2s7CiAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2NjYzsKICAgIHBhZGRpbmc6IDJweCAwOwp9Ci5yb3cgLm5hbWUgewogICAgd2lkdGg6IDMwJTsKfQoucm93IC52YWx1ZSB7CiAgICB3aWR0aDogNjklOwp9Ci5jb2wgewogICAgZGlzcGxheTogaW5saW5lLWJsb2NrOwp9Ci5sb2cgewogICAgZGlzcGxheTogbm9uZTsKICAgIHdpZHRoOiAxMDAlOwogICAgLyptYXgtaGVpZ2h0OiA1MDBweDsqLwogICAgLypvdmVyZmxvdzogYXV0bzsqLwogICAgLypib3JkZXI6IDFweCBzb2xpZDsqLwogICAgcG9zaXRpb246IHJlbGF0aXZlOwogICAgLypwYWRkaW5nOiA1cHg7Ki8KICAgIC8qbWFyZ2luOiA1cHg7Ki8KfQoubG9nLnNob3ctbG9nIHsgZGlzcGxheTogYmxvY2s7IH0KLmxvZy1oZWFkZXIgewogICAgYmFja2dyb3VuZDogYmxhY2s7CiAgICBjb2xvcjogd2hpdGU7CiAgICB3aWR0aDogMTAwJTsKICAgIGRpc3BsYXk6IGJsb2NrOwp9Ci5sb2ctY2VsbCB7CiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7CiAgICBtYXJnaW46IDAgMTBweCAwIDA7CiAgICBwYWRkaW5nOiAycHggMTBweDsKICAgIGZvbnQtc2l6ZTogMTJweDsKICAgIC8qbWluLXdpZHRoOiA2MHB4OyovCiAgICAvKm1heC13aWR0aDogMTYwcHg7Ki8KICAgIG92ZXJmbG93OmhpZGRlbjsKICAgIHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzOwogICAgd2hpdGUtc3BhY2U6IG5vd3JhcDsKICAgIAp9Ci5wcm9ncmVzcyB7CiAgICBiYWNrZ3JvdW5kOiAjY2NjOwogICAgcG9zaXRpb246IGZpeGVkOwogICAgdG9wOiAwOwogICAgcmlnaHQ6IDA7CiAgICBsZWZ0OiAwOwp9Ci5iYXIgewogICAgZGlzcGxheTogYmxvY2s7CiAgICBiYWNrZ3JvdW5kOiByZWQ7CiAgICB0ZXh0LWFsaWduOiByaWdodDsKfQouYmFyIGVtIHsKICAgIGZvbnQtc2l6ZTogMTBweDsKICAgIGZvbnQtd2VpZ2h0OiBib2xkOwogICAgZm9udC1zdHlsZTogbm9ybWFsOwogICAgcGFkZGluZzogMnB4IDVweDsKICAgIGRpc3BsYXk6IGJsb2NrOwp9Ci5mYWlsIHsgYmFja2dyb3VuZDogcmVkOyB9Ci5pbmZvIHsgYmFja2dyb3VuZDogbGlnaHRibHVlOyB9Ci5maW5pc2ggeyBiYWNrZ3JvdW5kOiBsaWdodGdyYXk7IH0KLndvcmtlciB7IGJhY2tncm91bmQ6IHBhbGVncmVlbjsgfQovKi5sb2ctZXh0cmEgeyBkaXNwbGF5OiBub25lOyB9Ki8KLmxvZy10eXBlIHsgd2lkdGg6IDUwcHg7IH0KLmxvZy13b3JrZXIgeyB3aWR0aDogNjBweDsgfQoubG9nLWRlc2MsIC5sb2ctdmFsdWUgewogICAgd2lkdGg6IDEzMHB4Owp9Ci5sb2ctdmlldyB7CiAgICBkaXNwbGF5OiBibG9jazsKfQoubG9nLWV4dHJhIHsKICAgIHdpZHRoOiAxNTBweDsKfQoud29ya19yb3cgewogICAgZGlzcGxheTogaW5saW5lLWJsb2NrOwp9Ci53b3JrX3JvdyBiLAoud29ya19yb3cgaSB7CiAgICBtYXJnaW46IDAgNXB4IDAgMAp9Ci53b3JrZXJzIHsKICAgIHBhZGRpbmc6IDVweDsKICAgIGRpc3BsYXk6IGJsb2NrOwp9Cgouc3RhdHVzIHsKICAgIGJvcmRlci1yYWRpdXM6IDEwcHg7CiAgICBmb250LXN0eWxlOiBub3JtYWw7CiAgICBwYWRkaW5nOiAxcHggNXB4OwogICAgZGlzcGxheTogaW5saW5lLWJsb2NrOwogICAgZm9udC13ZWlnaHQ6IGJvbGQ7CiAgICBmb250LXNpemU6IDAuOGVtOwp9Ci5zdGF0dXMtZ29vZCB7IGJhY2tncm91bmQ6IGRlZXBza3libHVlOyB9Ci5zdGF0dXMtbWVkaXVtIHsgYmFja2dyb3VuZDogbGlnaHRncmVlbjsgfQouc3RhdHVzLXNsb3cgeyBiYWNrZ3JvdW5kOiBsaWdodGNvcmFsOyB9Ci5zdGF0dXMtd2FybmluZyB7IGJhY2tncm91bmQ6IG1lZGl1bXB1cnBsZSB9Ci5zdGF0dXMtaW5hY3RpdmUgeyBiYWNrZ3JvdW5kOiBibGFjazsgY29sb3I6IHdoaXRlOyB9"),
        ('zepto.min.js', "LyogWmVwdG8gdjEuMi4wIC0gemVwdG8gZXZlbnQgYWpheCBmb3JtIGllIC0gemVwdG9qcy5jb20vbGljZW5zZSAqLwohZnVuY3Rpb24odCxlKXsiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShmdW5jdGlvbigpe3JldHVybiBlKHQpfSk6ZSh0KX0odGhpcyxmdW5jdGlvbih0KXt2YXIgZT1mdW5jdGlvbigpe2Z1bmN0aW9uICQodCl7cmV0dXJuIG51bGw9PXQ/U3RyaW5nKHQpOlNbQy5jYWxsKHQpXXx8Im9iamVjdCJ9ZnVuY3Rpb24gRih0KXtyZXR1cm4iZnVuY3Rpb24iPT0kKHQpfWZ1bmN0aW9uIGsodCl7cmV0dXJuIG51bGwhPXQmJnQ9PXQud2luZG93fWZ1bmN0aW9uIE0odCl7cmV0dXJuIG51bGwhPXQmJnQubm9kZVR5cGU9PXQuRE9DVU1FTlRfTk9ERX1mdW5jdGlvbiBSKHQpe3JldHVybiJvYmplY3QiPT0kKHQpfWZ1bmN0aW9uIFoodCl7cmV0dXJuIFIodCkmJiFrKHQpJiZPYmplY3QuZ2V0UHJvdG90eXBlT2YodCk9PU9iamVjdC5wcm90b3R5cGV9ZnVuY3Rpb24geih0KXt2YXIgZT0hIXQmJiJsZW5ndGgiaW4gdCYmdC5sZW5ndGgsbj1yLnR5cGUodCk7cmV0dXJuImZ1bmN0aW9uIiE9biYmIWsodCkmJigiYXJyYXkiPT1ufHwwPT09ZXx8Im51bWJlciI9PXR5cGVvZiBlJiZlPjAmJmUtMSBpbiB0KX1mdW5jdGlvbiBxKHQpe3JldHVybiBhLmNhbGwodCxmdW5jdGlvbih0KXtyZXR1cm4gbnVsbCE9dH0pfWZ1bmN0aW9uIEgodCl7cmV0dXJuIHQubGVuZ3RoPjA/ci5mbi5jb25jYXQuYXBwbHkoW10sdCk6dH1mdW5jdGlvbiBJKHQpe3JldHVybiB0LnJlcGxhY2UoLzo6L2csIi8iKS5yZXBsYWNlKC8oW0EtWl0rKShbQS1aXVthLXpdKS9nLCIkMV8kMiIpLnJlcGxhY2UoLyhbYS16XGRdKShbQS1aXSkvZywiJDFfJDIiKS5yZXBsYWNlKC9fL2csIi0iKS50b0xvd2VyQ2FzZSgpfWZ1bmN0aW9uIFYodCl7cmV0dXJuIHQgaW4gbD9sW3RdOmxbdF09bmV3IFJlZ0V4cCgiKF58XFxzKSIrdCsiKFxcc3wkKSIpfWZ1bmN0aW9uIF8odCxlKXtyZXR1cm4ibnVtYmVyIiE9dHlwZW9mIGV8fGhbSSh0KV0/ZTplKyJweCJ9ZnVuY3Rpb24gQih0KXt2YXIgZSxuO3JldHVybiBjW3RdfHwoZT1mLmNyZWF0ZUVsZW1lbnQodCksZi5ib2R5LmFwcGVuZENoaWxkKGUpLG49Z2V0Q29tcHV0ZWRTdHlsZShlLCIiKS5nZXRQcm9wZXJ0eVZhbHVlKCJkaXNwbGF5IiksZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGUpLCJub25lIj09biYmKG49ImJsb2NrIiksY1t0XT1uKSxjW3RdfWZ1bmN0aW9uIFUodCl7cmV0dXJuImNoaWxkcmVuImluIHQ/dS5jYWxsKHQuY2hpbGRyZW4pOnIubWFwKHQuY2hpbGROb2RlcyxmdW5jdGlvbih0KXtyZXR1cm4gMT09dC5ub2RlVHlwZT90OnZvaWQgMH0pfWZ1bmN0aW9uIFgodCxlKXt2YXIgbixyPXQ/dC5sZW5ndGg6MDtmb3Iobj0wO3I+bjtuKyspdGhpc1tuXT10W25dO3RoaXMubGVuZ3RoPXIsdGhpcy5zZWxlY3Rvcj1lfHwiIn1mdW5jdGlvbiBKKHQscixpKXtmb3IobiBpbiByKWkmJihaKHJbbl0pfHxMKHJbbl0pKT8oWihyW25dKSYmIVoodFtuXSkmJih0W25dPXt9KSxMKHJbbl0pJiYhTCh0W25dKSYmKHRbbl09W10pLEoodFtuXSxyW25dLGkpKTpyW25dIT09ZSYmKHRbbl09cltuXSl9ZnVuY3Rpb24gVyh0LGUpe3JldHVybiBudWxsPT1lP3IodCk6cih0KS5maWx0ZXIoZSl9ZnVuY3Rpb24gWSh0LGUsbixyKXtyZXR1cm4gRihlKT9lLmNhbGwodCxuLHIpOmV9ZnVuY3Rpb24gRyh0LGUsbil7bnVsbD09bj90LnJlbW92ZUF0dHJpYnV0ZShlKTp0LnNldEF0dHJpYnV0ZShlLG4pfWZ1bmN0aW9uIEsodCxuKXt2YXIgcj10LmNsYXNzTmFtZXx8IiIsaT1yJiZyLmJhc2VWYWwhPT1lO3JldHVybiBuPT09ZT9pP3IuYmFzZVZhbDpyOnZvaWQoaT9yLmJhc2VWYWw9bjp0LmNsYXNzTmFtZT1uKX1mdW5jdGlvbiBRKHQpe3RyeXtyZXR1cm4gdD8idHJ1ZSI9PXR8fCgiZmFsc2UiPT10PyExOiJudWxsIj09dD9udWxsOit0KyIiPT10Pyt0Oi9eW1xbXHtdLy50ZXN0KHQpP3IucGFyc2VKU09OKHQpOnQpOnR9Y2F0Y2goZSl7cmV0dXJuIHR9fWZ1bmN0aW9uIHR0KHQsZSl7ZSh0KTtmb3IodmFyIG49MCxyPXQuY2hpbGROb2Rlcy5sZW5ndGg7cj5uO24rKyl0dCh0LmNoaWxkTm9kZXNbbl0sZSl9dmFyIGUsbixyLGksTyxQLG89W10scz1vLmNvbmNhdCxhPW8uZmlsdGVyLHU9by5zbGljZSxmPXQuZG9jdW1lbnQsYz17fSxsPXt9LGg9eyJjb2x1bW4tY291bnQiOjEsY29sdW1uczoxLCJmb250LXdlaWdodCI6MSwibGluZS1oZWlnaHQiOjEsb3BhY2l0eToxLCJ6LWluZGV4IjoxLHpvb206MX0scD0vXlxzKjwoXHcrfCEpW14+XSo+LyxkPS9ePChcdyspXHMqXC8/Pig/OjxcL1wxPnwpJC8sbT0vPCg/IWFyZWF8YnJ8Y29sfGVtYmVkfGhyfGltZ3xpbnB1dHxsaW5rfG1ldGF8cGFyYW0pKChbXHc6XSspW14+XSopXC8+L2dpLGc9L14oPzpib2R5fGh0bWwpJC9pLHY9LyhbQS1aXSkvZyx5PVsidmFsIiwiY3NzIiwiaHRtbCIsInRleHQiLCJkYXRhIiwid2lkdGgiLCJoZWlnaHQiLCJvZmZzZXQiXSx4PVsiYWZ0ZXIiLCJwcmVwZW5kIiwiYmVmb3JlIiwiYXBwZW5kIl0sYj1mLmNyZWF0ZUVsZW1lbnQoInRhYmxlIiksRT1mLmNyZWF0ZUVsZW1lbnQoInRyIiksaj17dHI6Zi5jcmVhdGVFbGVtZW50KCJ0Ym9keSIpLHRib2R5OmIsdGhlYWQ6Yix0Zm9vdDpiLHRkOkUsdGg6RSwiKiI6Zi5jcmVhdGVFbGVtZW50KCJkaXYiKX0sdz0vY29tcGxldGV8bG9hZGVkfGludGVyYWN0aXZlLyxUPS9eW1x3LV0qJC8sUz17fSxDPVMudG9TdHJpbmcsTj17fSxBPWYuY3JlYXRlRWxlbWVudCgiZGl2IiksRD17dGFiaW5kZXg6InRhYkluZGV4IixyZWFkb25seToicmVhZE9ubHkiLCJmb3IiOiJodG1sRm9yIiwiY2xhc3MiOiJjbGFzc05hbWUiLG1heGxlbmd0aDoibWF4TGVuZ3RoIixjZWxsc3BhY2luZzoiY2VsbFNwYWNpbmciLGNlbGxwYWRkaW5nOiJjZWxsUGFkZGluZyIscm93c3Bhbjoicm93U3BhbiIsY29sc3BhbjoiY29sU3BhbiIsdXNlbWFwOiJ1c2VNYXAiLGZyYW1lYm9yZGVyOiJmcmFtZUJvcmRlciIsY29udGVudGVkaXRhYmxlOiJjb250ZW50RWRpdGFibGUifSxMPUFycmF5LmlzQXJyYXl8fGZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2YgQXJyYXl9O3JldHVybiBOLm1hdGNoZXM9ZnVuY3Rpb24odCxlKXtpZighZXx8IXR8fDEhPT10Lm5vZGVUeXBlKXJldHVybiExO3ZhciBuPXQubWF0Y2hlc3x8dC53ZWJraXRNYXRjaGVzU2VsZWN0b3J8fHQubW96TWF0Y2hlc1NlbGVjdG9yfHx0Lm9NYXRjaGVzU2VsZWN0b3J8fHQubWF0Y2hlc1NlbGVjdG9yO2lmKG4pcmV0dXJuIG4uY2FsbCh0LGUpO3ZhciByLGk9dC5wYXJlbnROb2RlLG89IWk7cmV0dXJuIG8mJihpPUEpLmFwcGVuZENoaWxkKHQpLHI9fk4ucXNhKGksZSkuaW5kZXhPZih0KSxvJiZBLnJlbW92ZUNoaWxkKHQpLHJ9LE89ZnVuY3Rpb24odCl7cmV0dXJuIHQucmVwbGFjZSgvLSsoLik/L2csZnVuY3Rpb24odCxlKXtyZXR1cm4gZT9lLnRvVXBwZXJDYXNlKCk6IiJ9KX0sUD1mdW5jdGlvbih0KXtyZXR1cm4gYS5jYWxsKHQsZnVuY3Rpb24oZSxuKXtyZXR1cm4gdC5pbmRleE9mKGUpPT1ufSl9LE4uZnJhZ21lbnQ9ZnVuY3Rpb24odCxuLGkpe3ZhciBvLHMsYTtyZXR1cm4gZC50ZXN0KHQpJiYobz1yKGYuY3JlYXRlRWxlbWVudChSZWdFeHAuJDEpKSksb3x8KHQucmVwbGFjZSYmKHQ9dC5yZXBsYWNlKG0sIjwkMT48LyQyPiIpKSxuPT09ZSYmKG49cC50ZXN0KHQpJiZSZWdFeHAuJDEpLG4gaW4ganx8KG49IioiKSxhPWpbbl0sYS5pbm5lckhUTUw9IiIrdCxvPXIuZWFjaCh1LmNhbGwoYS5jaGlsZE5vZGVzKSxmdW5jdGlvbigpe2EucmVtb3ZlQ2hpbGQodGhpcyl9KSksWihpKSYmKHM9cihvKSxyLmVhY2goaSxmdW5jdGlvbih0LGUpe3kuaW5kZXhPZih0KT4tMT9zW3RdKGUpOnMuYXR0cih0LGUpfSkpLG99LE4uWj1mdW5jdGlvbih0LGUpe3JldHVybiBuZXcgWCh0LGUpfSxOLmlzWj1mdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIE4uWn0sTi5pbml0PWZ1bmN0aW9uKHQsbil7dmFyIGk7aWYoIXQpcmV0dXJuIE4uWigpO2lmKCJzdHJpbmciPT10eXBlb2YgdClpZih0PXQudHJpbSgpLCI8Ij09dFswXSYmcC50ZXN0KHQpKWk9Ti5mcmFnbWVudCh0LFJlZ0V4cC4kMSxuKSx0PW51bGw7ZWxzZXtpZihuIT09ZSlyZXR1cm4gcihuKS5maW5kKHQpO2k9Ti5xc2EoZix0KX1lbHNle2lmKEYodCkpcmV0dXJuIHIoZikucmVhZHkodCk7aWYoTi5pc1oodCkpcmV0dXJuIHQ7aWYoTCh0KSlpPXEodCk7ZWxzZSBpZihSKHQpKWk9W3RdLHQ9bnVsbDtlbHNlIGlmKHAudGVzdCh0KSlpPU4uZnJhZ21lbnQodC50cmltKCksUmVnRXhwLiQxLG4pLHQ9bnVsbDtlbHNle2lmKG4hPT1lKXJldHVybiByKG4pLmZpbmQodCk7aT1OLnFzYShmLHQpfX1yZXR1cm4gTi5aKGksdCl9LHI9ZnVuY3Rpb24odCxlKXtyZXR1cm4gTi5pbml0KHQsZSl9LHIuZXh0ZW5kPWZ1bmN0aW9uKHQpe3ZhciBlLG49dS5jYWxsKGFyZ3VtZW50cywxKTtyZXR1cm4iYm9vbGVhbiI9PXR5cGVvZiB0JiYoZT10LHQ9bi5zaGlmdCgpKSxuLmZvckVhY2goZnVuY3Rpb24obil7Sih0LG4sZSl9KSx0fSxOLnFzYT1mdW5jdGlvbih0LGUpe3ZhciBuLHI9IiMiPT1lWzBdLGk9IXImJiIuIj09ZVswXSxvPXJ8fGk/ZS5zbGljZSgxKTplLHM9VC50ZXN0KG8pO3JldHVybiB0LmdldEVsZW1lbnRCeUlkJiZzJiZyPyhuPXQuZ2V0RWxlbWVudEJ5SWQobykpP1tuXTpbXToxIT09dC5ub2RlVHlwZSYmOSE9PXQubm9kZVR5cGUmJjExIT09dC5ub2RlVHlwZT9bXTp1LmNhbGwocyYmIXImJnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZT9pP3QuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShvKTp0LmdldEVsZW1lbnRzQnlUYWdOYW1lKGUpOnQucXVlcnlTZWxlY3RvckFsbChlKSl9LHIuY29udGFpbnM9Zi5kb2N1bWVudEVsZW1lbnQuY29udGFpbnM/ZnVuY3Rpb24odCxlKXtyZXR1cm4gdCE9PWUmJnQuY29udGFpbnMoZSl9OmZ1bmN0aW9uKHQsZSl7Zm9yKDtlJiYoZT1lLnBhcmVudE5vZGUpOylpZihlPT09dClyZXR1cm4hMDtyZXR1cm4hMX0sci50eXBlPSQsci5pc0Z1bmN0aW9uPUYsci5pc1dpbmRvdz1rLHIuaXNBcnJheT1MLHIuaXNQbGFpbk9iamVjdD1aLHIuaXNFbXB0eU9iamVjdD1mdW5jdGlvbih0KXt2YXIgZTtmb3IoZSBpbiB0KXJldHVybiExO3JldHVybiEwfSxyLmlzTnVtZXJpYz1mdW5jdGlvbih0KXt2YXIgZT1OdW1iZXIodCksbj10eXBlb2YgdDtyZXR1cm4gbnVsbCE9dCYmImJvb2xlYW4iIT1uJiYoInN0cmluZyIhPW58fHQubGVuZ3RoKSYmIWlzTmFOKGUpJiZpc0Zpbml0ZShlKXx8ITF9LHIuaW5BcnJheT1mdW5jdGlvbih0LGUsbil7cmV0dXJuIG8uaW5kZXhPZi5jYWxsKGUsdCxuKX0sci5jYW1lbENhc2U9TyxyLnRyaW09ZnVuY3Rpb24odCl7cmV0dXJuIG51bGw9PXQ/IiI6U3RyaW5nLnByb3RvdHlwZS50cmltLmNhbGwodCl9LHIudXVpZD0wLHIuc3VwcG9ydD17fSxyLmV4cHI9e30sci5ub29wPWZ1bmN0aW9uKCl7fSxyLm1hcD1mdW5jdGlvbih0LGUpe3ZhciBuLGksbyxyPVtdO2lmKHoodCkpZm9yKGk9MDtpPHQubGVuZ3RoO2krKyluPWUodFtpXSxpKSxudWxsIT1uJiZyLnB1c2gobik7ZWxzZSBmb3IobyBpbiB0KW49ZSh0W29dLG8pLG51bGwhPW4mJnIucHVzaChuKTtyZXR1cm4gSChyKX0sci5lYWNoPWZ1bmN0aW9uKHQsZSl7dmFyIG4scjtpZih6KHQpKXtmb3Iobj0wO248dC5sZW5ndGg7bisrKWlmKGUuY2FsbCh0W25dLG4sdFtuXSk9PT0hMSlyZXR1cm4gdH1lbHNlIGZvcihyIGluIHQpaWYoZS5jYWxsKHRbcl0scix0W3JdKT09PSExKXJldHVybiB0O3JldHVybiB0fSxyLmdyZXA9ZnVuY3Rpb24odCxlKXtyZXR1cm4gYS5jYWxsKHQsZSl9LHQuSlNPTiYmKHIucGFyc2VKU09OPUpTT04ucGFyc2UpLHIuZWFjaCgiQm9vbGVhbiBOdW1iZXIgU3RyaW5nIEZ1bmN0aW9uIEFycmF5IERhdGUgUmVnRXhwIE9iamVjdCBFcnJvciIuc3BsaXQoIiAiKSxmdW5jdGlvbih0LGUpe1NbIltvYmplY3QgIitlKyJdIl09ZS50b0xvd2VyQ2FzZSgpfSksci5mbj17Y29uc3RydWN0b3I6Ti5aLGxlbmd0aDowLGZvckVhY2g6by5mb3JFYWNoLHJlZHVjZTpvLnJlZHVjZSxwdXNoOm8ucHVzaCxzb3J0Om8uc29ydCxzcGxpY2U6by5zcGxpY2UsaW5kZXhPZjpvLmluZGV4T2YsY29uY2F0OmZ1bmN0aW9uKCl7dmFyIHQsZSxuPVtdO2Zvcih0PTA7dDxhcmd1bWVudHMubGVuZ3RoO3QrKyllPWFyZ3VtZW50c1t0XSxuW3RdPU4uaXNaKGUpP2UudG9BcnJheSgpOmU7cmV0dXJuIHMuYXBwbHkoTi5pc1oodGhpcyk/dGhpcy50b0FycmF5KCk6dGhpcyxuKX0sbWFwOmZ1bmN0aW9uKHQpe3JldHVybiByKHIubWFwKHRoaXMsZnVuY3Rpb24oZSxuKXtyZXR1cm4gdC5jYWxsKGUsbixlKX0pKX0sc2xpY2U6ZnVuY3Rpb24oKXtyZXR1cm4gcih1LmFwcGx5KHRoaXMsYXJndW1lbnRzKSl9LHJlYWR5OmZ1bmN0aW9uKHQpe3JldHVybiB3LnRlc3QoZi5yZWFkeVN0YXRlKSYmZi5ib2R5P3Qocik6Zi5hZGRFdmVudExpc3RlbmVyKCJET01Db250ZW50TG9hZGVkIixmdW5jdGlvbigpe3Qocil9LCExKSx0aGlzfSxnZXQ6ZnVuY3Rpb24odCl7cmV0dXJuIHQ9PT1lP3UuY2FsbCh0aGlzKTp0aGlzW3Q+PTA/dDp0K3RoaXMubGVuZ3RoXX0sdG9BcnJheTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdldCgpfSxzaXplOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGVuZ3RofSxyZW1vdmU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7bnVsbCE9dGhpcy5wYXJlbnROb2RlJiZ0aGlzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcyl9KX0sZWFjaDpmdW5jdGlvbih0KXtyZXR1cm4gby5ldmVyeS5jYWxsKHRoaXMsZnVuY3Rpb24oZSxuKXtyZXR1cm4gdC5jYWxsKGUsbixlKSE9PSExfSksdGhpc30sZmlsdGVyOmZ1bmN0aW9uKHQpe3JldHVybiBGKHQpP3RoaXMubm90KHRoaXMubm90KHQpKTpyKGEuY2FsbCh0aGlzLGZ1bmN0aW9uKGUpe3JldHVybiBOLm1hdGNoZXMoZSx0KX0pKX0sYWRkOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHIoUCh0aGlzLmNvbmNhdChyKHQsZSkpKSl9LGlzOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmxlbmd0aD4wJiZOLm1hdGNoZXModGhpc1swXSx0KX0sbm90OmZ1bmN0aW9uKHQpe3ZhciBuPVtdO2lmKEYodCkmJnQuY2FsbCE9PWUpdGhpcy5lYWNoKGZ1bmN0aW9uKGUpe3QuY2FsbCh0aGlzLGUpfHxuLnB1c2godGhpcyl9KTtlbHNle3ZhciBpPSJzdHJpbmciPT10eXBlb2YgdD90aGlzLmZpbHRlcih0KTp6KHQpJiZGKHQuaXRlbSk/dS5jYWxsKHQpOnIodCk7dGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHQpe2kuaW5kZXhPZih0KTwwJiZuLnB1c2godCl9KX1yZXR1cm4gcihuKX0saGFzOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbigpe3JldHVybiBSKHQpP3IuY29udGFpbnModGhpcyx0KTpyKHRoaXMpLmZpbmQodCkuc2l6ZSgpfSl9LGVxOmZ1bmN0aW9uKHQpe3JldHVybi0xPT09dD90aGlzLnNsaWNlKHQpOnRoaXMuc2xpY2UodCwrdCsxKX0sZmlyc3Q6ZnVuY3Rpb24oKXt2YXIgdD10aGlzWzBdO3JldHVybiB0JiYhUih0KT90OnIodCl9LGxhc3Q6ZnVuY3Rpb24oKXt2YXIgdD10aGlzW3RoaXMubGVuZ3RoLTFdO3JldHVybiB0JiYhUih0KT90OnIodCl9LGZpbmQ6ZnVuY3Rpb24odCl7dmFyIGUsbj10aGlzO3JldHVybiBlPXQ/Im9iamVjdCI9PXR5cGVvZiB0P3IodCkuZmlsdGVyKGZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztyZXR1cm4gby5zb21lLmNhbGwobixmdW5jdGlvbihlKXtyZXR1cm4gci5jb250YWlucyhlLHQpfSl9KToxPT10aGlzLmxlbmd0aD9yKE4ucXNhKHRoaXNbMF0sdCkpOnRoaXMubWFwKGZ1bmN0aW9uKCl7cmV0dXJuIE4ucXNhKHRoaXMsdCl9KTpyKCl9LGNsb3Nlc3Q6ZnVuY3Rpb24odCxlKXt2YXIgbj1bXSxpPSJvYmplY3QiPT10eXBlb2YgdCYmcih0KTtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKHIsbyl7Zm9yKDtvJiYhKGk/aS5pbmRleE9mKG8pPj0wOk4ubWF0Y2hlcyhvLHQpKTspbz1vIT09ZSYmIU0obykmJm8ucGFyZW50Tm9kZTtvJiZuLmluZGV4T2Yobyk8MCYmbi5wdXNoKG8pfSkscihuKX0scGFyZW50czpmdW5jdGlvbih0KXtmb3IodmFyIGU9W10sbj10aGlzO24ubGVuZ3RoPjA7KW49ci5tYXAobixmdW5jdGlvbih0KXtyZXR1cm4odD10LnBhcmVudE5vZGUpJiYhTSh0KSYmZS5pbmRleE9mKHQpPDA/KGUucHVzaCh0KSx0KTp2b2lkIDB9KTtyZXR1cm4gVyhlLHQpfSxwYXJlbnQ6ZnVuY3Rpb24odCl7cmV0dXJuIFcoUCh0aGlzLnBsdWNrKCJwYXJlbnROb2RlIikpLHQpfSxjaGlsZHJlbjpmdW5jdGlvbih0KXtyZXR1cm4gVyh0aGlzLm1hcChmdW5jdGlvbigpe3JldHVybiBVKHRoaXMpfSksdCl9LGNvbnRlbnRzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29udGVudERvY3VtZW50fHx1LmNhbGwodGhpcy5jaGlsZE5vZGVzKX0pfSxzaWJsaW5nczpmdW5jdGlvbih0KXtyZXR1cm4gVyh0aGlzLm1hcChmdW5jdGlvbih0LGUpe3JldHVybiBhLmNhbGwoVShlLnBhcmVudE5vZGUpLGZ1bmN0aW9uKHQpe3JldHVybiB0IT09ZX0pfSksdCl9LGVtcHR5OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3RoaXMuaW5uZXJIVE1MPSIifSl9LHBsdWNrOmZ1bmN0aW9uKHQpe3JldHVybiByLm1hcCh0aGlzLGZ1bmN0aW9uKGUpe3JldHVybiBlW3RdfSl9LHNob3c6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7Im5vbmUiPT10aGlzLnN0eWxlLmRpc3BsYXkmJih0aGlzLnN0eWxlLmRpc3BsYXk9IiIpLCJub25lIj09Z2V0Q29tcHV0ZWRTdHlsZSh0aGlzLCIiKS5nZXRQcm9wZXJ0eVZhbHVlKCJkaXNwbGF5IikmJih0aGlzLnN0eWxlLmRpc3BsYXk9Qih0aGlzLm5vZGVOYW1lKSl9KX0scmVwbGFjZVdpdGg6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuYmVmb3JlKHQpLnJlbW92ZSgpfSx3cmFwOmZ1bmN0aW9uKHQpe3ZhciBlPUYodCk7aWYodGhpc1swXSYmIWUpdmFyIG49cih0KS5nZXQoMCksaT1uLnBhcmVudE5vZGV8fHRoaXMubGVuZ3RoPjE7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihvKXtyKHRoaXMpLndyYXBBbGwoZT90LmNhbGwodGhpcyxvKTppP24uY2xvbmVOb2RlKCEwKTpuKX0pfSx3cmFwQWxsOmZ1bmN0aW9uKHQpe2lmKHRoaXNbMF0pe3IodGhpc1swXSkuYmVmb3JlKHQ9cih0KSk7Zm9yKHZhciBlOyhlPXQuY2hpbGRyZW4oKSkubGVuZ3RoOyl0PWUuZmlyc3QoKTtyKHQpLmFwcGVuZCh0aGlzKX1yZXR1cm4gdGhpc30sd3JhcElubmVyOmZ1bmN0aW9uKHQpe3ZhciBlPUYodCk7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihuKXt2YXIgaT1yKHRoaXMpLG89aS5jb250ZW50cygpLHM9ZT90LmNhbGwodGhpcyxuKTp0O28ubGVuZ3RoP28ud3JhcEFsbChzKTppLmFwcGVuZChzKX0pfSx1bndyYXA6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYXJlbnQoKS5lYWNoKGZ1bmN0aW9uKCl7cih0aGlzKS5yZXBsYWNlV2l0aChyKHRoaXMpLmNoaWxkcmVuKCkpfSksdGhpc30sY2xvbmU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jbG9uZU5vZGUoITApfSl9LGhpZGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jc3MoImRpc3BsYXkiLCJub25lIil9LHRvZ2dsZTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIG49cih0aGlzKTsodD09PWU/Im5vbmUiPT1uLmNzcygiZGlzcGxheSIpOnQpP24uc2hvdygpOm4uaGlkZSgpfSl9LHByZXY6ZnVuY3Rpb24odCl7cmV0dXJuIHIodGhpcy5wbHVjaygicHJldmlvdXNFbGVtZW50U2libGluZyIpKS5maWx0ZXIodHx8IioiKX0sbmV4dDpmdW5jdGlvbih0KXtyZXR1cm4gcih0aGlzLnBsdWNrKCJuZXh0RWxlbWVudFNpYmxpbmciKSkuZmlsdGVyKHR8fCIqIil9LGh0bWw6ZnVuY3Rpb24odCl7cmV0dXJuIDAgaW4gYXJndW1lbnRzP3RoaXMuZWFjaChmdW5jdGlvbihlKXt2YXIgbj10aGlzLmlubmVySFRNTDtyKHRoaXMpLmVtcHR5KCkuYXBwZW5kKFkodGhpcyx0LGUsbikpfSk6MCBpbiB0aGlzP3RoaXNbMF0uaW5uZXJIVE1MOm51bGx9LHRleHQ6ZnVuY3Rpb24odCl7cmV0dXJuIDAgaW4gYXJndW1lbnRzP3RoaXMuZWFjaChmdW5jdGlvbihlKXt2YXIgbj1ZKHRoaXMsdCxlLHRoaXMudGV4dENvbnRlbnQpO3RoaXMudGV4dENvbnRlbnQ9bnVsbD09bj8iIjoiIitufSk6MCBpbiB0aGlzP3RoaXMucGx1Y2soInRleHRDb250ZW50Iikuam9pbigiIik6bnVsbH0sYXR0cjpmdW5jdGlvbih0LHIpe3ZhciBpO3JldHVybiJzdHJpbmciIT10eXBlb2YgdHx8MSBpbiBhcmd1bWVudHM/dGhpcy5lYWNoKGZ1bmN0aW9uKGUpe2lmKDE9PT10aGlzLm5vZGVUeXBlKWlmKFIodCkpZm9yKG4gaW4gdClHKHRoaXMsbix0W25dKTtlbHNlIEcodGhpcyx0LFkodGhpcyxyLGUsdGhpcy5nZXRBdHRyaWJ1dGUodCkpKX0pOjAgaW4gdGhpcyYmMT09dGhpc1swXS5ub2RlVHlwZSYmbnVsbCE9KGk9dGhpc1swXS5nZXRBdHRyaWJ1dGUodCkpP2k6ZX0scmVtb3ZlQXR0cjpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7MT09PXRoaXMubm9kZVR5cGUmJnQuc3BsaXQoIiAiKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe0codGhpcyx0KX0sdGhpcyl9KX0scHJvcDpmdW5jdGlvbih0LGUpe3JldHVybiB0PURbdF18fHQsMSBpbiBhcmd1bWVudHM/dGhpcy5lYWNoKGZ1bmN0aW9uKG4pe3RoaXNbdF09WSh0aGlzLGUsbix0aGlzW3RdKX0pOnRoaXNbMF0mJnRoaXNbMF1bdF19LHJlbW92ZVByb3A6ZnVuY3Rpb24odCl7cmV0dXJuIHQ9RFt0XXx8dCx0aGlzLmVhY2goZnVuY3Rpb24oKXtkZWxldGUgdGhpc1t0XX0pfSxkYXRhOmZ1bmN0aW9uKHQsbil7dmFyIHI9ImRhdGEtIit0LnJlcGxhY2UodiwiLSQxIikudG9Mb3dlckNhc2UoKSxpPTEgaW4gYXJndW1lbnRzP3RoaXMuYXR0cihyLG4pOnRoaXMuYXR0cihyKTtyZXR1cm4gbnVsbCE9PWk/UShpKTplfSx2YWw6ZnVuY3Rpb24odCl7cmV0dXJuIDAgaW4gYXJndW1lbnRzPyhudWxsPT10JiYodD0iIiksdGhpcy5lYWNoKGZ1bmN0aW9uKGUpe3RoaXMudmFsdWU9WSh0aGlzLHQsZSx0aGlzLnZhbHVlKX0pKTp0aGlzWzBdJiYodGhpc1swXS5tdWx0aXBsZT9yKHRoaXNbMF0pLmZpbmQoIm9wdGlvbiIpLmZpbHRlcihmdW5jdGlvbigpe3JldHVybiB0aGlzLnNlbGVjdGVkfSkucGx1Y2soInZhbHVlIik6dGhpc1swXS52YWx1ZSl9LG9mZnNldDpmdW5jdGlvbihlKXtpZihlKXJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24odCl7dmFyIG49cih0aGlzKSxpPVkodGhpcyxlLHQsbi5vZmZzZXQoKSksbz1uLm9mZnNldFBhcmVudCgpLm9mZnNldCgpLHM9e3RvcDppLnRvcC1vLnRvcCxsZWZ0OmkubGVmdC1vLmxlZnR9OyJzdGF0aWMiPT1uLmNzcygicG9zaXRpb24iKSYmKHMucG9zaXRpb249InJlbGF0aXZlIiksbi5jc3Mocyl9KTtpZighdGhpcy5sZW5ndGgpcmV0dXJuIG51bGw7aWYoZi5kb2N1bWVudEVsZW1lbnQhPT10aGlzWzBdJiYhci5jb250YWlucyhmLmRvY3VtZW50RWxlbWVudCx0aGlzWzBdKSlyZXR1cm57dG9wOjAsbGVmdDowfTt2YXIgbj10aGlzWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3JldHVybntsZWZ0Om4ubGVmdCt0LnBhZ2VYT2Zmc2V0LHRvcDpuLnRvcCt0LnBhZ2VZT2Zmc2V0LHdpZHRoOk1hdGgucm91bmQobi53aWR0aCksaGVpZ2h0Ok1hdGgucm91bmQobi5oZWlnaHQpfX0sY3NzOmZ1bmN0aW9uKHQsZSl7aWYoYXJndW1lbnRzLmxlbmd0aDwyKXt2YXIgaT10aGlzWzBdO2lmKCJzdHJpbmciPT10eXBlb2YgdCl7aWYoIWkpcmV0dXJuO3JldHVybiBpLnN0eWxlW08odCldfHxnZXRDb21wdXRlZFN0eWxlKGksIiIpLmdldFByb3BlcnR5VmFsdWUodCl9aWYoTCh0KSl7aWYoIWkpcmV0dXJuO3ZhciBvPXt9LHM9Z2V0Q29tcHV0ZWRTdHlsZShpLCIiKTtyZXR1cm4gci5lYWNoKHQsZnVuY3Rpb24odCxlKXtvW2VdPWkuc3R5bGVbTyhlKV18fHMuZ2V0UHJvcGVydHlWYWx1ZShlKX0pLG99fXZhciBhPSIiO2lmKCJzdHJpbmciPT0kKHQpKWV8fDA9PT1lP2E9SSh0KSsiOiIrXyh0LGUpOnRoaXMuZWFjaChmdW5jdGlvbigpe3RoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkoSSh0KSl9KTtlbHNlIGZvcihuIGluIHQpdFtuXXx8MD09PXRbbl0/YSs9SShuKSsiOiIrXyhuLHRbbl0pKyI7Ijp0aGlzLmVhY2goZnVuY3Rpb24oKXt0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KEkobikpfSk7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3RoaXMuc3R5bGUuY3NzVGV4dCs9IjsiK2F9KX0saW5kZXg6ZnVuY3Rpb24odCl7cmV0dXJuIHQ/dGhpcy5pbmRleE9mKHIodClbMF0pOnRoaXMucGFyZW50KCkuY2hpbGRyZW4oKS5pbmRleE9mKHRoaXNbMF0pfSxoYXNDbGFzczpmdW5jdGlvbih0KXtyZXR1cm4gdD9vLnNvbWUuY2FsbCh0aGlzLGZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRlc3QoSyh0KSl9LFYodCkpOiExfSxhZGRDbGFzczpmdW5jdGlvbih0KXtyZXR1cm4gdD90aGlzLmVhY2goZnVuY3Rpb24oZSl7aWYoImNsYXNzTmFtZSJpbiB0aGlzKXtpPVtdO3ZhciBuPUsodGhpcyksbz1ZKHRoaXMsdCxlLG4pO28uc3BsaXQoL1xzKy9nKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3IodGhpcykuaGFzQ2xhc3ModCl8fGkucHVzaCh0KX0sdGhpcyksaS5sZW5ndGgmJksodGhpcyxuKyhuPyIgIjoiIikraS5qb2luKCIgIikpfX0pOnRoaXN9LHJlbW92ZUNsYXNzOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24obil7aWYoImNsYXNzTmFtZSJpbiB0aGlzKXtpZih0PT09ZSlyZXR1cm4gSyh0aGlzLCIiKTtpPUsodGhpcyksWSh0aGlzLHQsbixpKS5zcGxpdCgvXHMrL2cpLmZvckVhY2goZnVuY3Rpb24odCl7aT1pLnJlcGxhY2UoVih0KSwiICIpfSksSyh0aGlzLGkudHJpbSgpKX19KX0sdG9nZ2xlQ2xhc3M6ZnVuY3Rpb24odCxuKXtyZXR1cm4gdD90aGlzLmVhY2goZnVuY3Rpb24oaSl7dmFyIG89cih0aGlzKSxzPVkodGhpcyx0LGksSyh0aGlzKSk7cy5zcGxpdCgvXHMrL2cpLmZvckVhY2goZnVuY3Rpb24odCl7KG49PT1lPyFvLmhhc0NsYXNzKHQpOm4pP28uYWRkQ2xhc3ModCk6by5yZW1vdmVDbGFzcyh0KX0pfSk6dGhpc30sc2Nyb2xsVG9wOmZ1bmN0aW9uKHQpe2lmKHRoaXMubGVuZ3RoKXt2YXIgbj0ic2Nyb2xsVG9wImluIHRoaXNbMF07cmV0dXJuIHQ9PT1lP24/dGhpc1swXS5zY3JvbGxUb3A6dGhpc1swXS5wYWdlWU9mZnNldDp0aGlzLmVhY2gobj9mdW5jdGlvbigpe3RoaXMuc2Nyb2xsVG9wPXR9OmZ1bmN0aW9uKCl7dGhpcy5zY3JvbGxUbyh0aGlzLnNjcm9sbFgsdCl9KX19LHNjcm9sbExlZnQ6ZnVuY3Rpb24odCl7aWYodGhpcy5sZW5ndGgpe3ZhciBuPSJzY3JvbGxMZWZ0ImluIHRoaXNbMF07cmV0dXJuIHQ9PT1lP24/dGhpc1swXS5zY3JvbGxMZWZ0OnRoaXNbMF0ucGFnZVhPZmZzZXQ6dGhpcy5lYWNoKG4/ZnVuY3Rpb24oKXt0aGlzLnNjcm9sbExlZnQ9dH06ZnVuY3Rpb24oKXt0aGlzLnNjcm9sbFRvKHQsdGhpcy5zY3JvbGxZKX0pfX0scG9zaXRpb246ZnVuY3Rpb24oKXtpZih0aGlzLmxlbmd0aCl7dmFyIHQ9dGhpc1swXSxlPXRoaXMub2Zmc2V0UGFyZW50KCksbj10aGlzLm9mZnNldCgpLGk9Zy50ZXN0KGVbMF0ubm9kZU5hbWUpP3t0b3A6MCxsZWZ0OjB9OmUub2Zmc2V0KCk7cmV0dXJuIG4udG9wLT1wYXJzZUZsb2F0KHIodCkuY3NzKCJtYXJnaW4tdG9wIikpfHwwLG4ubGVmdC09cGFyc2VGbG9hdChyKHQpLmNzcygibWFyZ2luLWxlZnQiKSl8fDAsaS50b3ArPXBhcnNlRmxvYXQocihlWzBdKS5jc3MoImJvcmRlci10b3Atd2lkdGgiKSl8fDAsaS5sZWZ0Kz1wYXJzZUZsb2F0KHIoZVswXSkuY3NzKCJib3JkZXItbGVmdC13aWR0aCIpKXx8MCx7dG9wOm4udG9wLWkudG9wLGxlZnQ6bi5sZWZ0LWkubGVmdH19fSxvZmZzZXRQYXJlbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5vZmZzZXRQYXJlbnR8fGYuYm9keTt0JiYhZy50ZXN0KHQubm9kZU5hbWUpJiYic3RhdGljIj09cih0KS5jc3MoInBvc2l0aW9uIik7KXQ9dC5vZmZzZXRQYXJlbnQ7cmV0dXJuIHR9KX19LHIuZm4uZGV0YWNoPXIuZm4ucmVtb3ZlLFsid2lkdGgiLCJoZWlnaHQiXS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3ZhciBuPXQucmVwbGFjZSgvLi8sZnVuY3Rpb24odCl7cmV0dXJuIHRbMF0udG9VcHBlckNhc2UoKX0pO3IuZm5bdF09ZnVuY3Rpb24oaSl7dmFyIG8scz10aGlzWzBdO3JldHVybiBpPT09ZT9rKHMpP3NbImlubmVyIituXTpNKHMpP3MuZG9jdW1lbnRFbGVtZW50WyJzY3JvbGwiK25dOihvPXRoaXMub2Zmc2V0KCkpJiZvW3RdOnRoaXMuZWFjaChmdW5jdGlvbihlKXtzPXIodGhpcykscy5jc3ModCxZKHRoaXMsaSxlLHNbdF0oKSkpfSl9fSkseC5mb3JFYWNoKGZ1bmN0aW9uKG4saSl7dmFyIG89aSUyO3IuZm5bbl09ZnVuY3Rpb24oKXt2YXIgbixhLHM9ci5tYXAoYXJndW1lbnRzLGZ1bmN0aW9uKHQpe3ZhciBpPVtdO3JldHVybiBuPSQodCksImFycmF5Ij09bj8odC5mb3JFYWNoKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm5vZGVUeXBlIT09ZT9pLnB1c2godCk6ci56ZXB0by5pc1oodCk/aT1pLmNvbmNhdCh0LmdldCgpKTp2b2lkKGk9aS5jb25jYXQoTi5mcmFnbWVudCh0KSkpfSksaSk6Im9iamVjdCI9PW58fG51bGw9PXQ/dDpOLmZyYWdtZW50KHQpfSksdT10aGlzLmxlbmd0aD4xO3JldHVybiBzLmxlbmd0aDwxP3RoaXM6dGhpcy5lYWNoKGZ1bmN0aW9uKGUsbil7YT1vP246bi5wYXJlbnROb2RlLG49MD09aT9uLm5leHRTaWJsaW5nOjE9PWk/bi5maXJzdENoaWxkOjI9PWk/bjpudWxsO3ZhciBjPXIuY29udGFpbnMoZi5kb2N1bWVudEVsZW1lbnQsYSk7cy5mb3JFYWNoKGZ1bmN0aW9uKGUpe2lmKHUpZT1lLmNsb25lTm9kZSghMCk7ZWxzZSBpZighYSlyZXR1cm4gcihlKS5yZW1vdmUoKTthLmluc2VydEJlZm9yZShlLG4pLGMmJnR0KGUsZnVuY3Rpb24oZSl7aWYoIShudWxsPT1lLm5vZGVOYW1lfHwiU0NSSVBUIiE9PWUubm9kZU5hbWUudG9VcHBlckNhc2UoKXx8ZS50eXBlJiYidGV4dC9qYXZhc2NyaXB0IiE9PWUudHlwZXx8ZS5zcmMpKXt2YXIgbj1lLm93bmVyRG9jdW1lbnQ/ZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3OnQ7bi5ldmFsLmNhbGwobixlLmlubmVySFRNTCl9fSl9KX0pfSxyLmZuW28/bisiVG8iOiJpbnNlcnQiKyhpPyJCZWZvcmUiOiJBZnRlciIpXT1mdW5jdGlvbih0KXtyZXR1cm4gcih0KVtuXSh0aGlzKSx0aGlzfX0pLE4uWi5wcm90b3R5cGU9WC5wcm90b3R5cGU9ci5mbixOLnVuaXE9UCxOLmRlc2VyaWFsaXplVmFsdWU9USxyLnplcHRvPU4scn0oKTtyZXR1cm4gdC5aZXB0bz1lLHZvaWQgMD09PXQuJCYmKHQuJD1lKSxmdW5jdGlvbihlKXtmdW5jdGlvbiBoKHQpe3JldHVybiB0Ll96aWR8fCh0Ll96aWQ9bisrKX1mdW5jdGlvbiBwKHQsZSxuLHIpe2lmKGU9ZChlKSxlLm5zKXZhciBpPW0oZS5ucyk7cmV0dXJuKGFbaCh0KV18fFtdKS5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuIHQmJighZS5lfHx0LmU9PWUuZSkmJighZS5uc3x8aS50ZXN0KHQubnMpKSYmKCFufHxoKHQuZm4pPT09aChuKSkmJighcnx8dC5zZWw9PXIpfSl9ZnVuY3Rpb24gZCh0KXt2YXIgZT0oIiIrdCkuc3BsaXQoIi4iKTtyZXR1cm57ZTplWzBdLG5zOmUuc2xpY2UoMSkuc29ydCgpLmpvaW4oIiAiKX19ZnVuY3Rpb24gbSh0KXtyZXR1cm4gbmV3IFJlZ0V4cCgiKD86XnwgKSIrdC5yZXBsYWNlKCIgIiwiIC4qID8iKSsiKD86IHwkKSIpfWZ1bmN0aW9uIGcodCxlKXtyZXR1cm4gdC5kZWwmJiFmJiZ0LmUgaW4gY3x8ISFlfWZ1bmN0aW9uIHYodCl7cmV0dXJuIGxbdF18fGYmJmNbdF18fHR9ZnVuY3Rpb24geSh0LG4saSxvLHMsdSxmKXt2YXIgYz1oKHQpLHA9YVtjXXx8KGFbY109W10pO24uc3BsaXQoL1xzLykuZm9yRWFjaChmdW5jdGlvbihuKXtpZigicmVhZHkiPT1uKXJldHVybiBlKGRvY3VtZW50KS5yZWFkeShpKTt2YXIgYT1kKG4pO2EuZm49aSxhLnNlbD1zLGEuZSBpbiBsJiYoaT1mdW5jdGlvbih0KXt2YXIgbj10LnJlbGF0ZWRUYXJnZXQ7cmV0dXJuIW58fG4hPT10aGlzJiYhZS5jb250YWlucyh0aGlzLG4pP2EuZm4uYXBwbHkodGhpcyxhcmd1bWVudHMpOnZvaWQgMH0pLGEuZGVsPXU7dmFyIGM9dXx8aTthLnByb3h5PWZ1bmN0aW9uKGUpe2lmKGU9VChlKSwhZS5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpKXtlLmRhdGE9bzt2YXIgbj1jLmFwcGx5KHQsZS5fYXJncz09cj9bZV06W2VdLmNvbmNhdChlLl9hcmdzKSk7cmV0dXJuIG49PT0hMSYmKGUucHJldmVudERlZmF1bHQoKSxlLnN0b3BQcm9wYWdhdGlvbigpKSxufX0sYS5pPXAubGVuZ3RoLHAucHVzaChhKSwiYWRkRXZlbnRMaXN0ZW5lciJpbiB0JiZ0LmFkZEV2ZW50TGlzdGVuZXIodihhLmUpLGEucHJveHksZyhhLGYpKX0pfWZ1bmN0aW9uIHgodCxlLG4scixpKXt2YXIgbz1oKHQpOyhlfHwiIikuc3BsaXQoL1xzLykuZm9yRWFjaChmdW5jdGlvbihlKXtwKHQsZSxuLHIpLmZvckVhY2goZnVuY3Rpb24oZSl7ZGVsZXRlIGFbb11bZS5pXSwicmVtb3ZlRXZlbnRMaXN0ZW5lciJpbiB0JiZ0LnJlbW92ZUV2ZW50TGlzdGVuZXIodihlLmUpLGUucHJveHksZyhlLGkpKX0pfSl9ZnVuY3Rpb24gVCh0LG4pe3JldHVybihufHwhdC5pc0RlZmF1bHRQcmV2ZW50ZWQpJiYobnx8KG49dCksZS5lYWNoKHcsZnVuY3Rpb24oZSxyKXt2YXIgaT1uW2VdO3RbZV09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc1tyXT1iLGkmJmkuYXBwbHkobixhcmd1bWVudHMpfSx0W3JdPUV9KSx0LnRpbWVTdGFtcHx8KHQudGltZVN0YW1wPURhdGUubm93KCkpLChuLmRlZmF1bHRQcmV2ZW50ZWQhPT1yP24uZGVmYXVsdFByZXZlbnRlZDoicmV0dXJuVmFsdWUiaW4gbj9uLnJldHVyblZhbHVlPT09ITE6bi5nZXRQcmV2ZW50RGVmYXVsdCYmbi5nZXRQcmV2ZW50RGVmYXVsdCgpKSYmKHQuaXNEZWZhdWx0UHJldmVudGVkPWIpKSx0fWZ1bmN0aW9uIFModCl7dmFyIGUsbj17b3JpZ2luYWxFdmVudDp0fTtmb3IoZSBpbiB0KWoudGVzdChlKXx8dFtlXT09PXJ8fChuW2VdPXRbZV0pO3JldHVybiBUKG4sdCl9dmFyIHIsbj0xLGk9QXJyYXkucHJvdG90eXBlLnNsaWNlLG89ZS5pc0Z1bmN0aW9uLHM9ZnVuY3Rpb24odCl7cmV0dXJuInN0cmluZyI9PXR5cGVvZiB0fSxhPXt9LHU9e30sZj0ib25mb2N1c2luImluIHQsYz17Zm9jdXM6ImZvY3VzaW4iLGJsdXI6ImZvY3Vzb3V0In0sbD17bW91c2VlbnRlcjoibW91c2VvdmVyIixtb3VzZWxlYXZlOiJtb3VzZW91dCJ9O3UuY2xpY2s9dS5tb3VzZWRvd249dS5tb3VzZXVwPXUubW91c2Vtb3ZlPSJNb3VzZUV2ZW50cyIsZS5ldmVudD17YWRkOnkscmVtb3ZlOnh9LGUucHJveHk9ZnVuY3Rpb24odCxuKXt2YXIgcj0yIGluIGFyZ3VtZW50cyYmaS5jYWxsKGFyZ3VtZW50cywyKTtpZihvKHQpKXt2YXIgYT1mdW5jdGlvbigpe3JldHVybiB0LmFwcGx5KG4scj9yLmNvbmNhdChpLmNhbGwoYXJndW1lbnRzKSk6YXJndW1lbnRzKX07cmV0dXJuIGEuX3ppZD1oKHQpLGF9aWYocyhuKSlyZXR1cm4gcj8oci51bnNoaWZ0KHRbbl0sdCksZS5wcm94eS5hcHBseShudWxsLHIpKTplLnByb3h5KHRbbl0sdCk7dGhyb3cgbmV3IFR5cGVFcnJvcigiZXhwZWN0ZWQgZnVuY3Rpb24iKX0sZS5mbi5iaW5kPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdGhpcy5vbih0LGUsbil9LGUuZm4udW5iaW5kPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMub2ZmKHQsZSl9LGUuZm4ub25lPWZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybiB0aGlzLm9uKHQsZSxuLHIsMSl9O3ZhciBiPWZ1bmN0aW9uKCl7cmV0dXJuITB9LEU9ZnVuY3Rpb24oKXtyZXR1cm4hMX0saj0vXihbQS1aXXxyZXR1cm5WYWx1ZSR8bGF5ZXJbWFldJHx3ZWJraXRNb3ZlbWVudFtYWV0kKS8sdz17cHJldmVudERlZmF1bHQ6ImlzRGVmYXVsdFByZXZlbnRlZCIsc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiJpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCIsc3RvcFByb3BhZ2F0aW9uOiJpc1Byb3BhZ2F0aW9uU3RvcHBlZCJ9O2UuZm4uZGVsZWdhdGU9ZnVuY3Rpb24odCxlLG4pe3JldHVybiB0aGlzLm9uKGUsdCxuKX0sZS5mbi51bmRlbGVnYXRlPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdGhpcy5vZmYoZSx0LG4pfSxlLmZuLmxpdmU9ZnVuY3Rpb24odCxuKXtyZXR1cm4gZShkb2N1bWVudC5ib2R5KS5kZWxlZ2F0ZSh0aGlzLnNlbGVjdG9yLHQsbiksdGhpc30sZS5mbi5kaWU9ZnVuY3Rpb24odCxuKXtyZXR1cm4gZShkb2N1bWVudC5ib2R5KS51bmRlbGVnYXRlKHRoaXMuc2VsZWN0b3IsdCxuKSx0aGlzfSxlLmZuLm9uPWZ1bmN0aW9uKHQsbixhLHUsZil7dmFyIGMsbCxoPXRoaXM7cmV0dXJuIHQmJiFzKHQpPyhlLmVhY2godCxmdW5jdGlvbih0LGUpe2gub24odCxuLGEsZSxmKX0pLGgpOihzKG4pfHxvKHUpfHx1PT09ITF8fCh1PWEsYT1uLG49ciksKHU9PT1yfHxhPT09ITEpJiYodT1hLGE9ciksdT09PSExJiYodT1FKSxoLmVhY2goZnVuY3Rpb24ocixvKXtmJiYoYz1mdW5jdGlvbih0KXtyZXR1cm4geChvLHQudHlwZSx1KSx1LmFwcGx5KHRoaXMsYXJndW1lbnRzKX0pLG4mJihsPWZ1bmN0aW9uKHQpe3ZhciByLHM9ZSh0LnRhcmdldCkuY2xvc2VzdChuLG8pLmdldCgwKTtyZXR1cm4gcyYmcyE9PW8/KHI9ZS5leHRlbmQoUyh0KSx7Y3VycmVudFRhcmdldDpzLGxpdmVGaXJlZDpvfSksKGN8fHUpLmFwcGx5KHMsW3JdLmNvbmNhdChpLmNhbGwoYXJndW1lbnRzLDEpKSkpOnZvaWQgMH0pLHkobyx0LHUsYSxuLGx8fGMpfSkpfSxlLmZuLm9mZj1mdW5jdGlvbih0LG4saSl7dmFyIGE9dGhpcztyZXR1cm4gdCYmIXModCk/KGUuZWFjaCh0LGZ1bmN0aW9uKHQsZSl7YS5vZmYodCxuLGUpfSksYSk6KHMobil8fG8oaSl8fGk9PT0hMXx8KGk9bixuPXIpLGk9PT0hMSYmKGk9RSksYS5lYWNoKGZ1bmN0aW9uKCl7eCh0aGlzLHQsaSxuKX0pKX0sZS5mbi50cmlnZ2VyPWZ1bmN0aW9uKHQsbil7cmV0dXJuIHQ9cyh0KXx8ZS5pc1BsYWluT2JqZWN0KHQpP2UuRXZlbnQodCk6VCh0KSx0Ll9hcmdzPW4sdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dC50eXBlIGluIGMmJiJmdW5jdGlvbiI9PXR5cGVvZiB0aGlzW3QudHlwZV0/dGhpc1t0LnR5cGVdKCk6ImRpc3BhdGNoRXZlbnQiaW4gdGhpcz90aGlzLmRpc3BhdGNoRXZlbnQodCk6ZSh0aGlzKS50cmlnZ2VySGFuZGxlcih0LG4pfSl9LGUuZm4udHJpZ2dlckhhbmRsZXI9ZnVuY3Rpb24odCxuKXt2YXIgcixpO3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24obyxhKXtyPVMocyh0KT9lLkV2ZW50KHQpOnQpLHIuX2FyZ3M9bixyLnRhcmdldD1hLGUuZWFjaChwKGEsdC50eXBlfHx0KSxmdW5jdGlvbih0LGUpe3JldHVybiBpPWUucHJveHkociksci5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpPyExOnZvaWQgMH0pfSksaX0sImZvY3VzaW4gZm9jdXNvdXQgZm9jdXMgYmx1ciBsb2FkIHJlc2l6ZSBzY3JvbGwgdW5sb2FkIGNsaWNrIGRibGNsaWNrIG1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIGNoYW5nZSBzZWxlY3Qga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBlcnJvciIuc3BsaXQoIiAiKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe2UuZm5bdF09ZnVuY3Rpb24oZSl7cmV0dXJuIDAgaW4gYXJndW1lbnRzP3RoaXMuYmluZCh0LGUpOnRoaXMudHJpZ2dlcih0KX19KSxlLkV2ZW50PWZ1bmN0aW9uKHQsZSl7cyh0KXx8KGU9dCx0PWUudHlwZSk7dmFyIG49ZG9jdW1lbnQuY3JlYXRlRXZlbnQodVt0XXx8IkV2ZW50cyIpLHI9ITA7aWYoZSlmb3IodmFyIGkgaW4gZSkiYnViYmxlcyI9PWk/cj0hIWVbaV06bltpXT1lW2ldO3JldHVybiBuLmluaXRFdmVudCh0LHIsITApLFQobil9fShlKSxmdW5jdGlvbihlKXtmdW5jdGlvbiBwKHQsbixyKXt2YXIgaT1lLkV2ZW50KG4pO3JldHVybiBlKHQpLnRyaWdnZXIoaSxyKSwhaS5pc0RlZmF1bHRQcmV2ZW50ZWQoKX1mdW5jdGlvbiBkKHQsZSxuLGkpe3JldHVybiB0Lmdsb2JhbD9wKGV8fHIsbixpKTp2b2lkIDB9ZnVuY3Rpb24gbSh0KXt0Lmdsb2JhbCYmMD09PWUuYWN0aXZlKysmJmQodCxudWxsLCJhamF4U3RhcnQiKX1mdW5jdGlvbiBnKHQpe3QuZ2xvYmFsJiYhLS1lLmFjdGl2ZSYmZCh0LG51bGwsImFqYXhTdG9wIil9ZnVuY3Rpb24gdih0LGUpe3ZhciBuPWUuY29udGV4dDtyZXR1cm4gZS5iZWZvcmVTZW5kLmNhbGwobix0LGUpPT09ITF8fGQoZSxuLCJhamF4QmVmb3JlU2VuZCIsW3QsZV0pPT09ITE/ITE6dm9pZCBkKGUsbiwiYWpheFNlbmQiLFt0LGVdKX1mdW5jdGlvbiB5KHQsZSxuLHIpe3ZhciBpPW4uY29udGV4dCxvPSJzdWNjZXNzIjtuLnN1Y2Nlc3MuY2FsbChpLHQsbyxlKSxyJiZyLnJlc29sdmVXaXRoKGksW3QsbyxlXSksZChuLGksImFqYXhTdWNjZXNzIixbZSxuLHRdKSxiKG8sZSxuKX1mdW5jdGlvbiB4KHQsZSxuLHIsaSl7dmFyIG89ci5jb250ZXh0O3IuZXJyb3IuY2FsbChvLG4sZSx0KSxpJiZpLnJlamVjdFdpdGgobyxbbixlLHRdKSxkKHIsbywiYWpheEVycm9yIixbbixyLHR8fGVdKSxiKGUsbixyKX1mdW5jdGlvbiBiKHQsZSxuKXt2YXIgcj1uLmNvbnRleHQ7bi5jb21wbGV0ZS5jYWxsKHIsZSx0KSxkKG4sciwiYWpheENvbXBsZXRlIixbZSxuXSksZyhuKX1mdW5jdGlvbiBFKHQsZSxuKXtpZihuLmRhdGFGaWx0ZXI9PWopcmV0dXJuIHQ7dmFyIHI9bi5jb250ZXh0O3JldHVybiBuLmRhdGFGaWx0ZXIuY2FsbChyLHQsZSl9ZnVuY3Rpb24gaigpe31mdW5jdGlvbiB3KHQpe3JldHVybiB0JiYodD10LnNwbGl0KCI7IiwyKVswXSksdCYmKHQ9PWM/Imh0bWwiOnQ9PWY/Impzb24iOmEudGVzdCh0KT8ic2NyaXB0Ijp1LnRlc3QodCkmJiJ4bWwiKXx8InRleHQifWZ1bmN0aW9uIFQodCxlKXtyZXR1cm4iIj09ZT90Oih0KyImIitlKS5yZXBsYWNlKC9bJj9dezEsMn0vLCI/Iil9ZnVuY3Rpb24gUyh0KXt0LnByb2Nlc3NEYXRhJiZ0LmRhdGEmJiJzdHJpbmciIT1lLnR5cGUodC5kYXRhKSYmKHQuZGF0YT1lLnBhcmFtKHQuZGF0YSx0LnRyYWRpdGlvbmFsKSksIXQuZGF0YXx8dC50eXBlJiYiR0VUIiE9dC50eXBlLnRvVXBwZXJDYXNlKCkmJiJqc29ucCIhPXQuZGF0YVR5cGV8fCh0LnVybD1UKHQudXJsLHQuZGF0YSksdC5kYXRhPXZvaWQgMCl9ZnVuY3Rpb24gQyh0LG4scixpKXtyZXR1cm4gZS5pc0Z1bmN0aW9uKG4pJiYoaT1yLHI9bixuPXZvaWQgMCksZS5pc0Z1bmN0aW9uKHIpfHwoaT1yLHI9dm9pZCAwKSx7dXJsOnQsZGF0YTpuLHN1Y2Nlc3M6cixkYXRhVHlwZTppfX1mdW5jdGlvbiBPKHQsbixyLGkpe3ZhciBvLHM9ZS5pc0FycmF5KG4pLGE9ZS5pc1BsYWluT2JqZWN0KG4pO2UuZWFjaChuLGZ1bmN0aW9uKG4sdSl7bz1lLnR5cGUodSksaSYmKG49cj9pOmkrIlsiKyhhfHwib2JqZWN0Ij09b3x8ImFycmF5Ij09bz9uOiIiKSsiXSIpLCFpJiZzP3QuYWRkKHUubmFtZSx1LnZhbHVlKToiYXJyYXkiPT1vfHwhciYmIm9iamVjdCI9PW8/Tyh0LHUscixuKTp0LmFkZChuLHUpfSl9dmFyIGksbyxuPStuZXcgRGF0ZSxyPXQuZG9jdW1lbnQscz0vPHNjcmlwdFxiW148XSooPzooPyE8XC9zY3JpcHQ+KTxbXjxdKikqPFwvc2NyaXB0Pi9naSxhPS9eKD86dGV4dHxhcHBsaWNhdGlvbilcL2phdmFzY3JpcHQvaSx1PS9eKD86dGV4dHxhcHBsaWNhdGlvbilcL3htbC9pLGY9ImFwcGxpY2F0aW9uL2pzb24iLGM9InRleHQvaHRtbCIsbD0vXlxzKiQvLGg9ci5jcmVhdGVFbGVtZW50KCJhIik7aC5ocmVmPXQubG9jYXRpb24uaHJlZixlLmFjdGl2ZT0wLGUuYWpheEpTT05QPWZ1bmN0aW9uKGksbyl7aWYoISgidHlwZSJpbiBpKSlyZXR1cm4gZS5hamF4KGkpO3ZhciBjLHAscz1pLmpzb25wQ2FsbGJhY2ssYT0oZS5pc0Z1bmN0aW9uKHMpP3MoKTpzKXx8IlplcHRvIituKyssdT1yLmNyZWF0ZUVsZW1lbnQoInNjcmlwdCIpLGY9dFthXSxsPWZ1bmN0aW9uKHQpe2UodSkudHJpZ2dlckhhbmRsZXIoImVycm9yIix0fHwiYWJvcnQiKX0saD17YWJvcnQ6bH07cmV0dXJuIG8mJm8ucHJvbWlzZShoKSxlKHUpLm9uKCJsb2FkIGVycm9yIixmdW5jdGlvbihuLHIpe2NsZWFyVGltZW91dChwKSxlKHUpLm9mZigpLnJlbW92ZSgpLCJlcnJvciIhPW4udHlwZSYmYz95KGNbMF0saCxpLG8pOngobnVsbCxyfHwiZXJyb3IiLGgsaSxvKSx0W2FdPWYsYyYmZS5pc0Z1bmN0aW9uKGYpJiZmKGNbMF0pLGY9Yz12b2lkIDB9KSx2KGgsaSk9PT0hMT8obCgiYWJvcnQiKSxoKToodFthXT1mdW5jdGlvbigpe2M9YXJndW1lbnRzfSx1LnNyYz1pLnVybC5yZXBsYWNlKC9cPyguKyk9XD8vLCI/JDE9IithKSxyLmhlYWQuYXBwZW5kQ2hpbGQodSksaS50aW1lb3V0PjAmJihwPXNldFRpbWVvdXQoZnVuY3Rpb24oKXtsKCJ0aW1lb3V0Iil9LGkudGltZW91dCkpLGgpfSxlLmFqYXhTZXR0aW5ncz17dHlwZToiR0VUIixiZWZvcmVTZW5kOmosc3VjY2VzczpqLGVycm9yOmosY29tcGxldGU6aixjb250ZXh0Om51bGwsZ2xvYmFsOiEwLHhocjpmdW5jdGlvbigpe3JldHVybiBuZXcgdC5YTUxIdHRwUmVxdWVzdH0sYWNjZXB0czp7c2NyaXB0OiJ0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtamF2YXNjcmlwdCIsanNvbjpmLHhtbDoiYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbCIsaHRtbDpjLHRleHQ6InRleHQvcGxhaW4ifSxjcm9zc0RvbWFpbjohMSx0aW1lb3V0OjAscHJvY2Vzc0RhdGE6ITAsY2FjaGU6ITAsZGF0YUZpbHRlcjpqfSxlLmFqYXg9ZnVuY3Rpb24obil7dmFyIHUsZixzPWUuZXh0ZW5kKHt9LG58fHt9KSxhPWUuRGVmZXJyZWQmJmUuRGVmZXJyZWQoKTtmb3IoaSBpbiBlLmFqYXhTZXR0aW5ncyl2b2lkIDA9PT1zW2ldJiYoc1tpXT1lLmFqYXhTZXR0aW5nc1tpXSk7bShzKSxzLmNyb3NzRG9tYWlufHwodT1yLmNyZWF0ZUVsZW1lbnQoImEiKSx1LmhyZWY9cy51cmwsdS5ocmVmPXUuaHJlZixzLmNyb3NzRG9tYWluPWgucHJvdG9jb2wrIi8vIitoLmhvc3QhPXUucHJvdG9jb2wrIi8vIit1Lmhvc3QpLHMudXJsfHwocy51cmw9dC5sb2NhdGlvbi50b1N0cmluZygpKSwoZj1zLnVybC5pbmRleE9mKCIjIikpPi0xJiYocy51cmw9cy51cmwuc2xpY2UoMCxmKSksUyhzKTt2YXIgYz1zLmRhdGFUeXBlLHA9L1w/Lis9XD8vLnRlc3Qocy51cmwpO2lmKHAmJihjPSJqc29ucCIpLHMuY2FjaGUhPT0hMSYmKG4mJm4uY2FjaGU9PT0hMHx8InNjcmlwdCIhPWMmJiJqc29ucCIhPWMpfHwocy51cmw9VChzLnVybCwiXz0iK0RhdGUubm93KCkpKSwianNvbnAiPT1jKXJldHVybiBwfHwocy51cmw9VChzLnVybCxzLmpzb25wP3MuanNvbnArIj0/IjpzLmpzb25wPT09ITE/IiI6ImNhbGxiYWNrPT8iKSksZS5hamF4SlNPTlAocyxhKTt2YXIgUCxkPXMuYWNjZXB0c1tjXSxnPXt9LGI9ZnVuY3Rpb24odCxlKXtnW3QudG9Mb3dlckNhc2UoKV09W3QsZV19LEM9L14oW1x3LV0rOilcL1wvLy50ZXN0KHMudXJsKT9SZWdFeHAuJDE6dC5sb2NhdGlvbi5wcm90b2NvbCxOPXMueGhyKCksTz1OLnNldFJlcXVlc3RIZWFkZXI7aWYoYSYmYS5wcm9taXNlKE4pLHMuY3Jvc3NEb21haW58fGIoIlgtUmVxdWVzdGVkLVdpdGgiLCJYTUxIdHRwUmVxdWVzdCIpLGIoIkFjY2VwdCIsZHx8IiovKiIpLChkPXMubWltZVR5cGV8fGQpJiYoZC5pbmRleE9mKCIsIik+LTEmJihkPWQuc3BsaXQoIiwiLDIpWzBdKSxOLm92ZXJyaWRlTWltZVR5cGUmJk4ub3ZlcnJpZGVNaW1lVHlwZShkKSksKHMuY29udGVudFR5cGV8fHMuY29udGVudFR5cGUhPT0hMSYmcy5kYXRhJiYiR0VUIiE9cy50eXBlLnRvVXBwZXJDYXNlKCkpJiZiKCJDb250ZW50LVR5cGUiLHMuY29udGVudFR5cGV8fCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQiKSxzLmhlYWRlcnMpZm9yKG8gaW4gcy5oZWFkZXJzKWIobyxzLmhlYWRlcnNbb10pO2lmKE4uc2V0UmVxdWVzdEhlYWRlcj1iLE4ub25yZWFkeXN0YXRlY2hhbmdlPWZ1bmN0aW9uKCl7aWYoND09Ti5yZWFkeVN0YXRlKXtOLm9ucmVhZHlzdGF0ZWNoYW5nZT1qLGNsZWFyVGltZW91dChQKTt2YXIgdCxuPSExO2lmKE4uc3RhdHVzPj0yMDAmJk4uc3RhdHVzPDMwMHx8MzA0PT1OLnN0YXR1c3x8MD09Ti5zdGF0dXMmJiJmaWxlOiI9PUMpe2lmKGM9Y3x8dyhzLm1pbWVUeXBlfHxOLmdldFJlc3BvbnNlSGVhZGVyKCJjb250ZW50LXR5cGUiKSksImFycmF5YnVmZmVyIj09Ti5yZXNwb25zZVR5cGV8fCJibG9iIj09Ti5yZXNwb25zZVR5cGUpdD1OLnJlc3BvbnNlO2Vsc2V7dD1OLnJlc3BvbnNlVGV4dDt0cnl7dD1FKHQsYyxzKSwic2NyaXB0Ij09Yz8oMSxldmFsKSh0KToieG1sIj09Yz90PU4ucmVzcG9uc2VYTUw6Impzb24iPT1jJiYodD1sLnRlc3QodCk/bnVsbDplLnBhcnNlSlNPTih0KSl9Y2F0Y2gocil7bj1yfWlmKG4pcmV0dXJuIHgobiwicGFyc2VyZXJyb3IiLE4scyxhKX15KHQsTixzLGEpfWVsc2UgeChOLnN0YXR1c1RleHR8fG51bGwsTi5zdGF0dXM/ImVycm9yIjoiYWJvcnQiLE4scyxhKX19LHYoTixzKT09PSExKXJldHVybiBOLmFib3J0KCkseChudWxsLCJhYm9ydCIsTixzLGEpLE47dmFyIEE9ImFzeW5jImluIHM/cy5hc3luYzohMDtpZihOLm9wZW4ocy50eXBlLHMudXJsLEEscy51c2VybmFtZSxzLnBhc3N3b3JkKSxzLnhockZpZWxkcylmb3IobyBpbiBzLnhockZpZWxkcylOW29dPXMueGhyRmllbGRzW29dO2ZvcihvIGluIGcpTy5hcHBseShOLGdbb10pO3JldHVybiBzLnRpbWVvdXQ+MCYmKFA9c2V0VGltZW91dChmdW5jdGlvbigpe04ub25yZWFkeXN0YXRlY2hhbmdlPWosTi5hYm9ydCgpLHgobnVsbCwidGltZW91dCIsTixzLGEpfSxzLnRpbWVvdXQpKSxOLnNlbmQocy5kYXRhP3MuZGF0YTpudWxsKSxOfSxlLmdldD1mdW5jdGlvbigpe3JldHVybiBlLmFqYXgoQy5hcHBseShudWxsLGFyZ3VtZW50cykpfSxlLnBvc3Q9ZnVuY3Rpb24oKXt2YXIgdD1DLmFwcGx5KG51bGwsYXJndW1lbnRzKTtyZXR1cm4gdC50eXBlPSJQT1NUIixlLmFqYXgodCl9LGUuZ2V0SlNPTj1mdW5jdGlvbigpe3ZhciB0PUMuYXBwbHkobnVsbCxhcmd1bWVudHMpO3JldHVybiB0LmRhdGFUeXBlPSJqc29uIixlLmFqYXgodCl9LGUuZm4ubG9hZD1mdW5jdGlvbih0LG4scil7aWYoIXRoaXMubGVuZ3RoKXJldHVybiB0aGlzO3ZhciBhLGk9dGhpcyxvPXQuc3BsaXQoL1xzLyksdT1DKHQsbixyKSxmPXUuc3VjY2VzcztyZXR1cm4gby5sZW5ndGg+MSYmKHUudXJsPW9bMF0sYT1vWzFdKSx1LnN1Y2Nlc3M9ZnVuY3Rpb24odCl7aS5odG1sKGE/ZSgiPGRpdj4iKS5odG1sKHQucmVwbGFjZShzLCIiKSkuZmluZChhKTp0KSxmJiZmLmFwcGx5KGksYXJndW1lbnRzKX0sZS5hamF4KHUpLHRoaXN9O3ZhciBOPWVuY29kZVVSSUNvbXBvbmVudDtlLnBhcmFtPWZ1bmN0aW9uKHQsbil7dmFyIHI9W107cmV0dXJuIHIuYWRkPWZ1bmN0aW9uKHQsbil7ZS5pc0Z1bmN0aW9uKG4pJiYobj1uKCkpLG51bGw9PW4mJihuPSIiKSx0aGlzLnB1c2goTih0KSsiPSIrTihuKSl9LE8ocix0LG4pLHIuam9pbigiJiIpLnJlcGxhY2UoLyUyMC9nLCIrIil9fShlKSxmdW5jdGlvbih0KXt0LmZuLnNlcmlhbGl6ZUFycmF5PWZ1bmN0aW9uKCl7dmFyIGUsbixyPVtdLGk9ZnVuY3Rpb24odCl7cmV0dXJuIHQuZm9yRWFjaD90LmZvckVhY2goaSk6dm9pZCByLnB1c2goe25hbWU6ZSx2YWx1ZTp0fSl9O3JldHVybiB0aGlzWzBdJiZ0LmVhY2godGhpc1swXS5lbGVtZW50cyxmdW5jdGlvbihyLG8pe249by50eXBlLGU9by5uYW1lLGUmJiJmaWVsZHNldCIhPW8ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSYmIW8uZGlzYWJsZWQmJiJzdWJtaXQiIT1uJiYicmVzZXQiIT1uJiYiYnV0dG9uIiE9biYmImZpbGUiIT1uJiYoInJhZGlvIiE9biYmImNoZWNrYm94IiE9bnx8by5jaGVja2VkKSYmaSh0KG8pLnZhbCgpKX0pLHJ9LHQuZm4uc2VyaWFsaXplPWZ1bmN0aW9uKCl7dmFyIHQ9W107cmV0dXJuIHRoaXMuc2VyaWFsaXplQXJyYXkoKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3QucHVzaChlbmNvZGVVUklDb21wb25lbnQoZS5uYW1lKSsiPSIrZW5jb2RlVVJJQ29tcG9uZW50KGUudmFsdWUpKX0pLHQuam9pbigiJiIpfSx0LmZuLnN1Ym1pdD1mdW5jdGlvbihlKXtpZigwIGluIGFyZ3VtZW50cyl0aGlzLmJpbmQoInN1Ym1pdCIsZSk7ZWxzZSBpZih0aGlzLmxlbmd0aCl7dmFyIG49dC5FdmVudCgic3VibWl0Iik7dGhpcy5lcSgwKS50cmlnZ2VyKG4pLG4uaXNEZWZhdWx0UHJldmVudGVkKCl8fHRoaXMuZ2V0KDApLnN1Ym1pdCgpfXJldHVybiB0aGlzfX0oZSksZnVuY3Rpb24oKXt0cnl7Z2V0Q29tcHV0ZWRTdHlsZSh2b2lkIDApfWNhdGNoKGUpe3ZhciBuPWdldENvbXB1dGVkU3R5bGU7dC5nZXRDb21wdXRlZFN0eWxlPWZ1bmN0aW9uKHQsZSl7dHJ5e3JldHVybiBuKHQsZSl9Y2F0Y2gocil7cmV0dXJuIG51bGx9fX19KCksZX0pOw=="),
        ('main.js', 'KGZ1bmN0aW9uKCQpewogICAgU3RyaW5nLnByb3RvdHlwZS5oYXNoQ29kZSA9IGZ1bmN0aW9uKCkgewogICAgICAgIHZhciBoYXNoID0gMCwgaSwgY2hyLCBsZW47CiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gaGFzaDsKICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7CiAgICAgICAgICAgIGNociAgID0gdGhpcy5jaGFyQ29kZUF0KGkpOwogICAgICAgICAgICBoYXNoICA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgY2hyOwogICAgICAgICAgICBoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlcgogICAgICAgIH0KICAgICAgICByZXR1cm4gaGFzaDsKICAgIH07CiAgICB2YXIgbWFpbiA9ICQoJyNtYWluJyksCiAgICAgICAgcHJvZ3Jlc3MgPSAkKCcjcHJvZ3Jlc3MnKSwKICAgICAgICB3b3JrZXJzID0gJCgnI3dvcmtlcnMnKSwKICAgICAgICBsb2cgPSAkKCcjbG9nJyksCiAgICAgICAgd29ya19kY3QgPSB7fSwKICAgICAgICBsb2dfZmlsZW5hbWUgPSBudWxsLAogICAgICAgIGxvZ190ZW1wbGF0ZSA9ICc8c3BhbiBjbGFzcz0iOkNMQVNTTkFNRToiIHRpdGxlPSI6QUxUOiI+OlRFWFQ6PC9zcGFuPicsCiAgICAgICAgdmlldyA9IGZ1bmN0aW9uKGh0bWwpIHsKICAgICAgICAgICAgbWFpbi5odG1sKGh0bWwpCiAgICAgICAgfSwKICAgICAgICBnZXRfd29ya19yYXRlID0gZnVuY3Rpb24gKG9iaikgewogICAgICAgICAgICB2YXIgaHRtbCA9IFtdCiAgICAgICAgICAgICQuZWFjaChvYmosIGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkgewogICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhuYW1lLCB2YWx1ZSkKICAgICAgICAgICAgICAgIGh0bWwucHVzaCgnPGRpdiBjbGFzcz0id29ya19yb3ciPjxiPicrIG5hbWUgKyc8L2I+PGk+JysgdmFsdWUgKyc8L2k+PC9kaXY+JykKICAgICAgICAgICAgfSkKICAgICAgICAgICAgcmV0dXJuIGh0bWwuam9pbignJykKICAgICAgICB9LAogICAgICAgIGdldF90aW1lX2ZtdCA9IGZ1bmN0aW9uIChtaWxsaXNlY29uZHMsIGxpbWl0KSB7CiAgICAgICAgICAgIGlmKC9eWzAtOV0rXC5bMC05XSskLy50ZXN0KFN0cmluZyhtaWxsaXNlY29uZHMpKSkgewogICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRzICo9IDEwMDA7IC8vIHB5dGhvbiBtaWdodCB1c2Ugc2Vjb25kcwogICAgICAgICAgICB9CiAgICAgICAgICAgIHZhciBpID0gMDsKICAgICAgICAgICAgdmFyIG1zID0gbWlsbGlzZWNvbmRzOwogICAgICAgICAgICB2YXIgZm10ID0gWydzZWMnLCAnbWluJywgJ2hyJywgJ2RheScsICd3ZWVrJywgJ21vbnRoJywgJ3llYXInLCAnZGVjYWRlJywgJ2NlbXR1cnknXTsKICAgICAgICAgICAgdmFyIG1vZCA9IFsxMDAwLCA2MCwgNjAsIDI0LCA3LCA0LCAxMiwgMTAsIDEwMCwgMV07CiAgICAgICAgICAgIHZhciBwbHVyYWwgPSBudWxsOwoKICAgICAgICAgICAgZm9yKGk7IGkgPCBmbXQubGVuZ3RoLTE7IGkrKykgewogICAgICAgICAgICAgICAgbXMgLz0gbW9kW2ldOwogICAgICAgICAgICAgICAgY29uc29sZS5sb2cobXMsIGZtdFtpXSkKICAgICAgICAgICAgICAgIGlmIChsaW1pdCAmJiBsaW1pdCA9PT0gZm10W2ldKSB7IGJyZWFrOyB9CiAgICAgICAgICAgICAgICBpZiAocGFyc2VJbnQobXMvbW9kW2krMV0sIDEwKSA9PSAwKSB7IGJyZWFrOyB9CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIHBsdXJhbCA9IChtcyA+IDEgPyAncycgOiAnJyk7CiAgICAgICAgICAgIHJldHVybiBbCiAgICAgICAgICAgICAgICBTdHJpbmcoaSA+IDIgPyBtcy50b0ZpeGVkKDIpIDogcGFyc2VJbnQobXMsIDEwKSkucmVwbGFjZSgvXC5bMF0rJC8sICcnKSwKICAgICAgICAgICAgICAgIGZtdFtpXSArIHBsdXJhbAogICAgICAgICAgICBdLmpvaW4oJyAnKTsKCiAgICAgICAgfSwKICAgICAgICBnZXRfbm9kZV9zdGF0dXMgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHsKICAgICAgICAgICAgY29uc29sZS5sb2codmFsdWUsIHZhbHVlLnNwbGl0KCdAJykpOwogICAgICAgICAgICB2YXIgYXJyYXkgPSB2YWx1ZS5zcGxpdCgnQCcpOwogICAgICAgICAgICB2YXIgaXAgPSBhcnJheVswXTsKICAgICAgICAgICAgdmFyIHRzID0gYXJyYXlbMV07CiAgICAgICAgICAgIHZhciBkaWZmID0gMAogICAgICAgICAgICBpZiAoIS9eWzAtOV0rJC8udGVzdCh0cykpIHsgcmV0dXJuIHZhbHVlOyB9CiAgICAgICAgICAgIHRzID0gcGFyc2VJbnQodHMsIDEwKSAqIDEwMDAKICAgICAgICAgICAgZGlmZiA9IChwYXJzZUludChuZXcgRGF0ZSgpLnZhbHVlT2YoKSwgMTApIC0gdHMpLzEwMDA7CiAgICAgICAgICAgIGNsYXNzbmFtZSA9IGRpZmYgPCAoNSo2MCoxMDAwKSA/ICdnb29kJyA6CiAgICAgICAgICAgICAgICAgICAgICAgIGRpZmYgPCAoMTUqNjAqMTAwMCkgPyAnbWVkaXVtJyA6ICAKICAgICAgICAgICAgICAgICAgICAgICAgZGlmZiA8ICgzMCo2MCoxMDAwKSA/ICdzbG93JyA6ICAKICAgICAgICAgICAgICAgICAgICAgICAgZGlmZiA8ICg2MCo2MCoxMDAwKSA/ICd3YXJuaW5nJyA6CiAgICAgICAgICAgICAgICAgICAgICAgICdpbmFjdGl2ZSc7CgogICAgICAgICAgICBjb25zb2xlLmxvZygnZGlmZicsIGRpZmYsIHR5cGVvZiB0cykKICAgICAgICAgICAgcmV0dXJuIHZhbHVlICsgJyA8ZW0gY2xhc3M9InN0YXR1cyBzdGF0dXMtJyArIGNsYXNzbmFtZSArICciPicgKyBnZXRfdGltZV9mbXQoZGlmZikgKyAnPC9lbT4nOwogICAgICAgIH0sCiAgICAgICAgdHN2X3RvX2h0bWwgPSBmdW5jdGlvbiAocm93KSB7CiAgICAgICAgICAgIGlmICghcm93LnRyaW0oKSkgeyByZXR1cm4gJyc7IH0KICAgICAgICAgICAgcm93ID0gcm93LnRyaW0oKS5zcGxpdCgnXHQnKQogICAgICAgICAgICBpZiAocm93Lmxlbmd0aCA8IDQpIHsgcmV0dXJuICcnOyB9CgogICAgICAgICAgICB2YXIgZGlmZgogICAgICAgICAgICB2YXIgd29ya19pZCA9IHJvd1sxXS50b0xvd2VyQ2FzZSgpLnRyaW0oKQogICAgICAgICAgICB2YXIgd29ya190eXBlID0gKHJvd1syXS5tYXRjaCgvXihmaW5pc2h8c3RhcnQpL2kpIHx8IFsnJ10pWzBdLnRvTG93ZXJDYXNlKCkKCiAgICAgICAgICAgIHZhciBjbGFzc25hbWVzID0gWwogICAgICAgICAgICAgICAgcm93WzBdLnRvTG93ZXJDYXNlKCkudHJpbSgpLAogICAgICAgICAgICAgICAgcm93WzFdLnRvTG93ZXJDYXNlKCkudHJpbSgpLAogICAgICAgICAgICAgICAgd29ya190eXBlLAogICAgICAgICAgICBdLmpvaW4oJyAnKQoKICAgICAgICAgICAgaWYgKHdvcmtfdHlwZSAmJiAvXmZpbmlzaC9pLnRlc3Qod29ya190eXBlKSkgewogICAgICAgICAgICAgICAgd29ya19kY3QgPSB3b3JrX2RjdCB8fCB7fQogICAgICAgICAgICAgICAgd29ya19kY3Rbd29ya19pZF0gPSB3b3JrX2RjdFt3b3JrX2lkXSB8fCAwCiAgICAgICAgICAgICAgICB3b3JrX2RjdFt3b3JrX2lkXSArPSAxCiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIHJvd1swXSA9IGxvZ190ZW1wbGF0ZS5yZXBsYWNlKCc6VEVYVDonLCByb3dbMF0pLnJlcGxhY2UoJzpDTEFTU05BTUU6JywgJ2xvZy1jZWxsIGxvZy10eXBlJykucmVwbGFjZSgnOkFMVDonLCAnJykKICAgICAgICAgICAgcm93WzFdID0gbG9nX3RlbXBsYXRlLnJlcGxhY2UoJzpURVhUOicsIHJvd1sxXSkucmVwbGFjZSgnOkNMQVNTTkFNRTonLCAnbG9nLWNlbGwgbG9nLXdvcmtlcicpLnJlcGxhY2UoJzpBTFQ6JywgJycpCiAgICAgICAgICAgIHJvd1syXSA9IGxvZ190ZW1wbGF0ZS5yZXBsYWNlKCc6VEVYVDonLCByb3dbMl0pLnJlcGxhY2UoJzpDTEFTU05BTUU6JywgJ2xvZy1jZWxsIGxvZy1kZXNjJykucmVwbGFjZSgnOkFMVDonLCAnJykKICAgICAgICAgICAgcm93WzNdID0gbG9nX3RlbXBsYXRlLnJlcGxhY2UoJzpURVhUOicsIHJvd1szXS5zcGxpdCgvW1wvXFxdLykuc2xpY2UoLTEpLmpvaW4oJy8nKSkucmVwbGFjZSgnOkNMQVNTTkFNRTonLCAnbG9nLWNlbGwgbG9nLXZhbHVlJykucmVwbGFjZSgnOkFMVDonLCByb3dbM10pCiAgICAgICAgICAgIHJvd1s0XSA9IGxvZ190ZW1wbGF0ZS5yZXBsYWNlKCc6VEVYVDonLCByb3dbNF0gfHwgJycpLnJlcGxhY2UoJzpDTEFTU05BTUU6JywgJ2xvZy1jZWxsIGxvZy1leHRyYScpLnJlcGxhY2UoJzpBTFQ6JywgJycpCiAgICAgICAgICAgIHJvd1s1XSA9IGxvZ190ZW1wbGF0ZS5yZXBsYWNlKCc6VEVYVDonLCByb3dbNV0gJiYgcm93WzVdLnNwbGl0KCcgJylbMV0gfHwgJycpLnJlcGxhY2UoJzpDTEFTU05BTUU6JywgJ2xvZy1jZWxsIGxvZy10aW1lJykucmVwbGFjZSgnOkFMVDonLCByb3dbNV0pCgogICAgICAgICAgICByZXR1cm4gJzxkaXYgY2xhc3M9ImxvZy1yb3cgJyArIGNsYXNzbmFtZXMgKyAnIj4nICsgcm93LmpvaW4oJycpICsgJzwvZGl2PicKCiAgICAgICAgfSwKICAgICAgICBnZXRfbG9nID0gbnVsbCwKICAgICAgICBnZXRfbG9nX2ZpbGUgPSBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgIHZhciBhcnJheSA9IG51bGwsCiAgICAgICAgICAgICAgICBwYXJ0aWFsLAogICAgICAgICAgICAgICAgaHRtbCA9ICcnLAogICAgICAgICAgICAgICAgcGFyc2UgPSBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgICAgICAgJC5nZXQobG9nX2ZpbGVuYW1lLCBmdW5jdGlvbiAodHh0KSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5ID0gdHh0LnNwbGl0KCdcbicpCiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gYXJyYXkubGVuZ3RoIC0gMSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdzsKCiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChuKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3cgPSBhcnJheVtuXS50cmltKCkgfHwgJyc7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocm93KSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbCArPSB0c3ZfdG9faHRtbChyb3cpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuIC09IDEKICAgICAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICAgICAgbG9nLmh0bWwoaHRtbCkKICAgICAgICAgICAgICAgICAgICAgICAgd29ya2Vycy5odG1sKGdldF93b3JrX3JhdGUod29ya19kY3QpKTsKICAgICAgICAgICAgICAgICAgICAgICAgd29ya19kY3QgPSBudWxsOwogICAgICAgICAgICAgICAgICAgIH0pCiAgICAgICAgICAgICAgICB9OwogICAgICAgICAgICByZXR1cm4gc2V0VGltZW91dChwYXJzZSwgMCk7CiAgICAgICAgfSwKICAgICAgICBnZXRfY29uZmlnX3JvdyA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkgewogICAgICAgICAgICB2YXIgaXNfbm9kZV93b3JrZXIgPSAvXm5vZGUvaS50ZXN0KG5hbWUpCiAgICAgICAgICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlIHx8ICcnKS50cmltKCkKICAgICAgICAgICAgdmFsdWUgPSBpc19ub2RlX3dvcmtlciA/IGdldF9ub2RlX3N0YXR1cyhuYW1lLCB2YWx1ZSkgOiB2YWx1ZS50cmltKCkKICAgICAgICAgICAgcmV0dXJuIFsKICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPSJyb3ciPicsCiAgICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9ImNvbCBuYW1lIj4nLAogICAgICAgICAgICAgICAgICAgICAgICBuYW1lLAogICAgICAgICAgICAgICAgICAgICc8L2Rpdj4nLAogICAgICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPSJjb2wgdmFsdWUiPicsCiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLAogICAgICAgICAgICAgICAgICAgICc8L2Rpdj4nLAogICAgICAgICAgICAgICAgJzwvZGl2PicKICAgICAgICAgICAgXS5qb2luKCdcbicpOwogICAgICAgIH0sCiAgICAgICAgZGF0ZV9zdHJpbmcgPSBmdW5jdGlvbiAoZCkgewogICAgICAgICAgICBkID0gIWQgPyBuZXcgRGF0ZSgpIDogbmV3IERhdGUoZCkKICAgICAgICAgICAgZCA9IGQudG9TdHJpbmcoKS5zcGxpdCgnICcpLnNsaWNlKDAsNSkKICAgICAgICAgICAgcmV0dXJuIGQuam9pbignICcpCiAgICAgICAgfSwKICAgICAgICBub3cgPSBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSgpLnZhbHVlT2YoKTsKICAgICAgICB9LAogICAgICAgIGNvbmZpZ19kYXRlcyA9IHt9LAogICAgICAgIHBvbGxfcHJldmlvdXMgPSBudWxsLAogICAgICAgIHBvbGxfc2VydmVyID0gZnVuY3Rpb24gKCkgewogICAgICAgICAgICAkLmdldEpTT04oJ2NvbmZpZy5qc29uJywgZnVuY3Rpb24oZCl7CiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKGQpOwogICAgICAgICAgICAgICAgdmFyIHRleHQgPSBbXSwKICAgICAgICAgICAgICAgICAgICBwZXJjZW50ID0gMCwKICAgICAgICAgICAgICAgICAgICBrZXlzID0gW10sCiAgICAgICAgICAgICAgICAgICAgaGFzaCA9IChKU09OLnN0cmluZ2lmeShkKSkuaGFzaENvZGUoKTsKCiAgICAgICAgICAgICAgICBpZiAoaGFzaCA9PT0gcG9sbF9wcmV2aW91cykgewogICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCJOb3RoaW5nIHRvIGRvIC4uLiIpOwogICAgICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHBvbGxfcHJldmlvdXMgPSBoYXNoOwoKICAgICAgICAgICAgICAgIGlmIChnZXRfbG9nKSB7IGdldF9sb2dfZmlsZSgpOyB9CgoKICAgICAgICAgICAgICAgICQoZCkuZWFjaChmdW5jdGlvbihrZXksIG9iail7CiAgICAgICAgICAgICAgICAgICAgbG9nX2ZpbGVuYW1lID0gbG9nX2ZpbGVuYW1lIHx8IG9iai5sb2dfZmlsZW5hbWU7CiAgICAgICAgICAgICAgICAgICAgb2JqWydkYXRlX25vdyddID0gZGF0ZV9zdHJpbmcoKQogICAgICAgICAgICAgICAgICAgICQuZWFjaChvYmosIGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkgewogICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhuYW1lLCB2YWx1ZSkKICAgICAgICAgICAgICAgICAgICAgICAgcGVyY2VudCA9IChvYmoudG90YWxfcHJvZ3Jlc3MgLyBvYmoudG90YWxfZmlsZXMpICogMTAwCgogICAgICAgICAgICAgICAgICAgICAgICBpZiAoL15kYXRlL2kudGVzdChuYW1lKSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqW25hbWVdID0gZGF0ZV9zdHJpbmcodmFsdWUpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWdfZGF0ZXNbbmFtZV0gPSBwYXJzZUludChuZXcgRGF0ZSh2YWx1ZSkudmFsdWVPZigpLCAxMCk7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEvXmRzdHxzcmN8d29yay9pLnRlc3QobmFtZSkpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleXMucHVzaChuYW1lKQogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfSk7CgogICAgICAgICAgICAgICAgICAgICQuZWFjaChrZXlzLnNvcnQoKSwgZnVuY3Rpb24gKGksIHZhbCkgewogICAgICAgICAgICAgICAgICAgICAgICB0ZXh0LnB1c2goZ2V0X2NvbmZpZ19yb3codmFsLCBvYmpbdmFsXSkpCiAgICAgICAgICAgICAgICAgICAgfSkKCgogICAgICAgICAgICAgICAgICAgIC8vIHRleHQucHVzaChnZXRfY29uZmlnX3Jvdygnbm93Jywgbm93KCkpKQogICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUuY2xlYXIoKQogICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKG5vdygpKQogICAgICAgICAgICAgICAgfSkKICAgICAgICAgICAgICAgIHByb2dyZXNzLmh0bWwoJzxkaXYgY2xhc3M9ImJhciIgc3R5bGU9IndpZHRoOicgKyBwZXJjZW50ICsgJyUiPjxlbT4nICsgcGFyc2VJbnQocGVyY2VudCwxMCkgKyAnJTwvZW0+PC9kaXY+JykKICAgICAgICAgICAgICAgIHZpZXcodGV4dC5qb2luKCdcbicpKQogICAgICAgICAgICB9KTsKICAgICAgICB9OwogICAgcG9sbF9zZXJ2ZXIoKTsKICAgIHNldEludGVydmFsKHBvbGxfc2VydmVyLCAxNTAwMCk7CgogICAgdmFyIGxvZ0NvbnRhaW5lciA9ICQoJyNsb2ctY29udGFpbmVyJyk7CiAgICAkKCcjbG9hZF9sb2cnKS5vbignY2xpY2snLCBmdW5jdGlvbiAoZSkgewogICAgICAgIGUucHJldmVudERlZmF1bHQoKTsKICAgICAgICBsb2dDb250YWluZXIudG9nZ2xlQ2xhc3MoJ3Nob3ctbG9nJyk7CiAgICAgICAgZ2V0X2xvZyA9IGxvZ0NvbnRhaW5lci5oYXNDbGFzcygnc2hvdy1sb2cnKSAvLyBnbG9iYWwgc3dpdGNoCiAgICAgICAgaWYgKCFnZXRfbG9nKSB7CiAgICAgICAgICAgIC8vIGhpZGUgYW5kIGVtcHR5IGNvbnRlbnRzCiAgICAgICAgICAgIGxvZy5odG1sKCdMb2FkaW5nIC4uLi4nKTsKICAgICAgICAgICAgJCh0aGlzKS5odG1sKCdWaWV3IGxvZyBmaWxlJyk7CiAgICAgICAgICAgIHJldHVybjsKICAgICAgICB9CgogICAgICAgICQodGhpcykuaHRtbCgnSGlkZSBsb2cgZmlsZScpOwogICAgICAgIHJldHVybiBnZXRfbG9nX2ZpbGUoKTsKCiAgICB9KTsKfShaZXB0bykp')
    ]
    output = dst + get_prefix()
    for asset in dct:
        # unpack and write the asset to the asset folder
        filename, b64string = (asset)
        b64string = base64.b64decode(b64string)
        open(output + filename, 'w').write(b64string)
    
    os.chdir(output)
    PORT = 8000

    Handler = SimpleHTTPServer.SimpleHTTPRequestHandler
    httpd = SocketServer.TCPServer(("", PORT), Handler)
    print "serving at port", PORT
    httpd.serve_forever()


def banner():
    print "\nM A K E - P R O X Y (version:%s)\n\n" % version()

def cls(n=None):
    # os specific "clear"
    # or line feeds
    method = 'cls' if os.name == 'nt' else 'clear'
    if n == None or n < 1:
        os.system(method)
        banner()
        return
    print "\n"*n

def slash():
    delim = "\\" if os.name == 'nt' else "/"
    return delim

def folder_fix(path, char=None):
    # if char == None: char = slash()
    # if char == '\\': char += char #regex escape "\"
    char = "|"
    path = path.replace(r'[\r]', '').strip()
    fix_path = path or ''
    fix_path = fix_path.replace('\\', char)
    fix_path = fix_path.replace('/', char)

    fix_path = fix_path.replace('||', '|')
    fix_path = fix_path.replace('|', slash())


    return fix_path

def tsv(type='NONE', desc="No description", value=" ", extra=" "):
    who = config('worker') or 'UNKOWN'
    ts = now()
    return '\t'.join([type.ljust(8), who, str(desc), str(value), (extra), ts])

def sizeof_fmt(num, suffix='B'):
    for unit in ['','K','M','G','T','P','E','Z']:
        if abs(num) < 1024.0:
            return "%3.2f %s%s" % (num, unit, suffix)
        num /= 1024.0
    return "%.1f%s%s" % (num, 'Yi', suffix)

def now(style='%Y/%m/%d %H:%M:%S'):
    
    if style == 'epoc':
        # javascript uses millisecons
        return str(int(time.time()*1000.0))
    if style == 'time': style = '%H:%M:%S'
    if style == 'microsecond': style = '%H:%M:%S.%f'
    if style == 'filename': style = '%Y%m%d_%H%M%S'
    return str(datetime.datetime.now().strftime(style))



# the FFMPEG parameters
def get_ffmpeg_command(input_filename, output_filename):
    global which_ffmpeg

    command = []
    command += ['"%s"' % which_ffmpeg]
    command += ['-i', '"%s"' % input_filename]
    command += ['-strict', '-2']
    command += ['-c:a', 'copy']
    command += ['-c:v', config('prores_encoder')]
    command += ['-profile:v', str(config('prores_profile'))]
    command += ['-qscale:v', str(config('prores_quality'))]

    if config('dimensions') != 'none':
        command += ['-s', config('dimensions')]

    command += ['-threads', 'none', '-hide_banner', '-y']
    # command += ['-progress', 'http://localhost:8000/bruce/'] ## cause web server error on POST
    command += ['-metadata comment="ORIGINAL: %s"' % (input_filename)]
    command += ['"%s.part.mov"' % output_filename]
    return ' '.join(command)

def get_bash_script(input_relative, output_relative):

    bash_string = [
        input_relative,
        output_relative
    ]

    return '\n'.join(bash_string)


def ignore_folder(path):
    global ignore_folders

    path = path.replace(config('dst'), '')
    path = pipe_path(path)
    path = re.sub('^\|+|\|+$', '', path.strip())
    paths = path.split('|')
    cat = '|'
    match = False
    for folder in paths:
        cat += folder + '|'
        if match == False and ignore_folders.has_key(cat):
            print "MATCHED INGORE: %s" % (cat)
            match = True
            msg = tsv("IGNORE", "Ignore base folder", path)
            if not errors.count(msg):
                errors.append(msg)
                append_to_log(msg)

    return match

def create_output_assets():

    global file_count
    global total_bytes
    global ignore_folders

    source = str(config('src'))
    destination = str(config('dst'))

    print "ignore_folders", ignore_folders

    for root, subdirs, files in os.walk(source):
        for file in files:

            # skip dot files (eg ._myVideoFile.MOV)
            if re.compile("^\.").match(file):
                continue

            file = re.sub('\r', '', file)
            print "FILE ::::", file

            input_filename = "%s%s%s" % (root, slash(), file)
            input_extension = re.search('([a-z0-9]+)$', input_filename, re.IGNORECASE).group(0)
            input_file_size = os.path.getsize(input_filename)

            base =  input_filename.replace(source, "")
            input_folder = base

            output_folder = ("%s%s" % (destination, base)).replace(file, '')
            output_extension = re.compile('mov', re.IGNORECASE).match(input_extension) and input_extension or 'mov'
            output_filename = output_folder + re.sub('([^\.]{2,})$', output_extension, file)

            base_folder = "%s" % (output_folder.replace(destination, ''))


            output_filename = folder_fix(output_filename)
            output_folder = folder_fix(output_folder)

            input_filename = folder_fix(input_filename)
            input_folder = folder_fix(input_folder)

            input_rel = input_filename.replace(source, "")
            output_rel = output_filename.replace(destination, "")

            # skip ignored folders
            if (ignore_folder(base_folder)):
                continue

            # skip non-video media
            if not is_video.match(file):
                continue

            # skip large files
            byte_limit = config('byte_limit')
            if (byte_limit > 0) and (input_file_size > byte_limit):
                msg = tsv("WARN", "Size limit exceeded", base + ' ' + sizeof_fmt(input_file_size), sizeof_fmt(byte_limit))
                errors.append(msg)
                append_to_log(msg)
                continue

            # skip existing transcoded files
            if skip_existing_files and os.path.isfile(output_filename):
                msg = tsv("SKIP", "Output media exists", output_filename)
                errors.append(msg)
                append_to_log(msg)
                continue

            # is this a transcode (ie input does not match output)
            if input_extension.lower() != output_extension.lower():
                if config('transcode') == 'none':
                    msg = tsv("SKIP", "Do not transcode", input_filename , "%s to %s" % (input_extension,output_extension))
                    errors.append(msg)
                    append_to_log(msg)
                    continue

                msg = tsv("TRANS", "Transcode media", input_filename , "%s to %s" % (input_extension,output_extension))
                errors.append(msg)
                append_to_log(msg)


            # create destination output folder(s)
            if not os.path.isdir(output_folder):
                # print "Create folder:", output_folder
                try:
                    os.makedirs(output_folder)
                except:
                    msg = tsv("ERROR", "Can't create folder", output_folder)
                    if not errors.count(msg):
                        errors.append(msg)
                        append_to_log(msg)
                    continue

            # create the ffmpeg command file, if the output media does not exist
            if os.path.isdir(output_folder) and not os.path.isfile(output_filename):
                # print "Create bash file: %s.ffmpeg" % (output_filename)
                try:
                    bash_file = open("%s.ffmpeg" % (output_filename), 'w')
                    bash_string = get_bash_script(input_rel, output_rel)
                    bash_file.write(bash_string)
                    bash_file.close()
                    file_count += 1
                    total_bytes += input_file_size
                    new_row = [bash_string, input_filename, output_filename]
                    print "ADDED", input_filename, len(stack)
                    stack.append(new_row)
                    append_to_log(tsv("ADDED", "Added media file", input_filename, sizeof_fmt(input_file_size)))
                except:
                    # errors.append("Can't create file (%s.ffmpeg)" % (output_filename))
                    msg = tsv("ERROR", "Can't create command file", "%s.ffmpeg" % (output_filename))
                    errors.append(msg)
                    append_to_log(msg)

    append_to_log(tsv("INFO", "File count", file_count))
    append_to_log(tsv("INFO", "Total bytes", sizeof_fmt(total_bytes)))

    config('total_files', file_count)
    config('total_bytes', total_bytes)
    update_progress(0)

    return


def append_to_log(text, filename=None):
    global log_file_name
    destination = config('dst')
    filename = get_prefix(filename or log_file_name)
    log_file = open("%s/%s" % (destination, filename), 'ab+')
    log_file.write(text+'\n')
    log_file.close()

def present_warnings():
    if len(errors):
        cls(3)
        print "-------------------------------------------"
        print " WARNINGS that occured while preparing"
        print "-------------------------------------------"
        print "\n - " + ('\n - '.join(errors))
        cls(3)
    return

def get_next_task():
    # returns a FFMPEG metadata file
    destination = str(config('dst'))
    work = []

    for root, subdirs, files in os.walk(destination):
        for file in files:
            filename = "%s%s%s" % (root, slash(), file)
            if ignore_folder(filename):
                continue

            if re.search('ffmpeg$', file):
                cls()
                work.append(filename)
                get_progress()
                break
        if len(work): break

    if len(work):
        return work[0]

    return None
def encode_type(ifp='', ofp=''):
    ext = re.compile('.*\.([0-9a-z]+)$', re.IGNORECASE)
    print "encode_type (%s) (%s)" % (re.match(ext, ifp).group(1), re.match(ext, ofp).group(1))
    ifp = re.match(ext, ifp).group(1) or ''
    ofp = re.match(ext, ofp).group(1) or ''
    return "%s to %s" % (ifp.upper(), ofp.upper())

def create_proxy_footage():
    global which_ffmpeg

    src = config('src')
    dst =  config('dst')
    task_filename = get_next_task()

    append_to_log(tsv('WORKER', 'Worker joined ... ', config('worker_addr')))
    while task_filename:

        base_filename = re.sub('.ffmpeg$', '', task_filename)
        base_filename = re.sub(dst, '', base_filename)

        src_filename = src + base_filename
        dst_filename = dst + base_filename

        print "%s: (%s) %s" % (config('worker'), config('worker_addr'), task_filename)

        try:
            os.rename(task_filename, task_filename+'.locked')
        except:
            print "File exists %s %s" % (task_filename, task_filename+'.locked')
            task_filename = get_next_task()


        cls(3)
        work_time = now('time')
        work_worker = config('worker')

        # open the task file and extract src, dest and
        # add create the relative paths for the batch command
        task_file = open(task_filename+'.locked', 'r').read()
        open(task_filename+'.locked', 'w').write(task_file + '\n' + config('worker') +  ':' + config('worker_addr'))
        task_file = task_file.split('\n')

        abs_input = folder_fix(src + slash() + task_file[0])
        abs_output = folder_fix(dst + slash() + task_file[1])
        input_size = os.path.getsize(abs_input)

        media_encode = encode_type(abs_input, abs_output)
        task_transcode = '' if (task_file[0].lower() == task_file[1].lower) else ' TRANSCODE '
        task_cmd =  get_ffmpeg_command(abs_input, abs_output)

        # print "Executing %d of %d (%d%%)\n\n" % (i, n, int((float(i-1)/float(n)) * 100))
        append_to_log(tsv('WORK', 'Start transcoding', task_filename, "%s (%s)" % (sizeof_fmt(input_size), media_encode)))

        subprocess.call(task_cmd, shell=True)
        work_time = now('time')


        # clean-up: rename temp file
        if os.path.isfile(abs_output + '.part.mov'):
            os.rename(abs_output + '.part.mov', abs_output)
            output_size = os.path.getsize(abs_output)
            ratio = float(output_size)/float(input_size)
            report = 'DEFALTE' if ratio else 'INFLATE'
            append_to_log(tsv('WORK', 'Finished transcoding', task_filename, "%s %s %2.2f" % (sizeof_fmt(output_size), report, ratio)))
            update_progress()
            status = 'SUCCESS'
            snooze = 5

            # delete ffmpeg command file IF transcode was successful
            if os.path.isfile(abs_output +'.ffmpeg.locked'):
                os.remove(abs_output + '.ffmpeg.locked')

        else:
            msg = tsv("FAIL", "Failed to create output media", abs_output)
            status = 'ERROR'
            append_to_log(msg)
            print msg
            snooze = 15

        # loop to next file ... or exit
        # print "finished .. zzzzzzz"
        # time.sleep(20)
        print "\n\n%s: Safe to quit. Snoozing for %s seconds" % (status, snooze)
        time.sleep(snooze)
        task_filename = get_next_task()

    append_to_log(tsv('WORKER', 'Worker left ... all done', config('worker'), now()))
    cls()

def pipe_path(path):
    path = path.strip()
    return re.sub('[\\\/]', '|', path)

def strip_trailing_slash(path=''):
    if not path: return ''
    return re.sub('[\\\/]+$', '', path)

def get_ignored_folders():
    global ignore_file_name
    folder = str(config('dst'))
    file_name = "%s%s%s" % (folder, slash(), get_prefix(ignore_file_name))
    lines = {}
    try:
        file = open(file_name, 'r')
        append_to_log(tsv("INFO", "Ignore file found"))

    except:
        append_to_log(tsv("INFO", "Nothing to ignore"))
        return lines

    # return array of folders to ignore
    for line in file:
        clean_path = pipe_path(line)
        lines[clean_path] = True

    return lines

def config(key, value=None):
    global config_dct
    # returns config value
    if value != None:
        config_dct[key] = value

    value = config_dct[key]

    if type(value) is unicode:
        value = value.encode('ascii')

    return value


def update_progress(value=1):
    # update config dictionary
    # open existing config
    global destination
    global config_filename

    config_path = "%s%s%s" % (destination, slash(), config_filename)
    config_json = json.loads(open(config_path, 'r').read())

    total_progress = config_json['total_progress']
    total_progress += int(value) or 0
    config('total_progress', total_progress)

    config_json['total_progress'] = total_progress
    config_json['total_files'] = config('total_files')
    config_json['total_bytes'] = config('total_bytes')
    config_json['node_'+config('worker')] = config('worker_addr') + '@' + now('epoc')


    config_file = open(config_path, 'w')
    config_file.write(json.dumps(config_json, indent=4))
    config_file.close()

def get_progress(summary=False):
    diff = (float(config('total_progress')) / float(config('total_files')))* 100
    cls(1)
    print "%s  %2.1f%% (%sof%s)" % (('|'*int(diff)).ljust(int(diff)).ljust(100, ':'), diff,config('total_progress'), config('total_files'))


def get_input(msg='User input message', typeis='string', values=[], read_only=False):
    input_msg = (msg.ljust(60, '.') + '(%s): ') % (values[0])
    if read_only == True:
        print "%s" % input_msg
        return values[0]

    input_value = str(raw_input(input_msg or ''))
    def get_string(val):
        if input_value == '': return str(values[0])
        if input_value in values: return input_value
        print "Invalid option. (\"%s\")" % ('", "'.join(values))
        return get_input(msg, typeis, values)

    def get_number(val):
        if input_value == '': return values[0]
        temp_value = int(input_value) or -1
        if temp_value >= values[1] and temp_value <= values[2]: return int(temp_value)
        print "Invalid option. min: %s max: %s" % (values[1], values[2])
        return get_input(msg, typeis, values)

    def get_resize(val):
        if input_value == '': return values[0]
        temp_value = str(input_value)
        if re.compile('^[0-9]{2,4}x[0-9]{2,4}$').match(temp_value): return str(temp_value)
        if re.compile('^no.*$').match(temp_value): return 'none'
        print "Invalid option. \"no\" or (WIDTH)x(HEIGHT) eg: %s" % (values[1:])
        return get_input(msg, typeis, values)

    def get_array(val):
        if input_value == '': return values[0]
        temp_value = str(input_value).lower().strip()
        if re.compile('^(no|none)$').match(temp_value): return 'none'
        if re.compile('^(all)$').match(temp_value): return 'all'
        # TODO: validate know video extensions
        return str(temp_value)

    switch = {
        'string': get_string,
        'number': get_number,
        'dimension': get_resize,
        'array': get_array,
    }

    return switch[typeis](input_value)

def get_prefix(filename=''):
    prefix = ".mkproxy"
    return "%s%s%s" % (prefix, slash(), filename)

if __name__ == "__main__":

    cls()


    parser = argparse.ArgumentParser()
    parser.add_argument("-i", type=str, help="(String) Source folder to scan for video assets")
    parser.add_argument("-o", type=str, help="(String) Destination folder for the transcoded media")
    parser.add_argument("-d", action="store_true", help="Delete and re-create the config file.")
    parser.add_argument("-n", type=str, help="Name the worker, used in the event log")
    parser.add_argument("-w", action="store_true", help="Create a webserver monitor")

    args = parser.parse_args()

    cwd = os.getcwd()
    source = args.i or None
    destination = args.o or None
    worker_id = args.n or str("worker_" + now('filename'))
    worker_addr = socket.gethostbyname(socket.gethostname())
    delete_config_file = args.d
    create_web_assets = args.w

    # global variables
    # the most common video extensions to match and convert
    is_video = re.compile('.*(mp4|mov|qt|avi|wmv|m4v|mpeg|3gp|mxf|mkv)$', re.IGNORECASE)
    which_ffmpeg = find_executable("ffmpeg")
    gigabyte = 1024.0**3.0
    stack = [] # the FFMPEG execution stack
    errors = [] # the collated runtime errors
    info = [] # the information feedback log file
    file_count = 0
    total_bytes = 0
    skip_existing_files = True
    create_ffmpeg_files = False
    ignore_file_name = get_prefix("ignore.txt")
    config_filename = get_prefix("config.json")
    config_dct = {
        "src": source,
        "dst": destination,
        "prores_encoder": 'prores_ks',  # 'prores' 'prores_ks' (supports 4444) 'prores_aw'
        "prores_profile": "0", # 0:Proxy, 1:LT, 2:SQ and 3:HQ
        "prores_quality": "22", # huge file: [0 |||||| 9-13 |||||||| 32] terrible quality
        "dimensions": '1920x1080',
        "gig_limit": 20,
        "byte_limit": None,
        "total_files": 0,
        "total_bytes": 0.0,
        "transcode": 'all',
        "total_progress": 0,
        "worker": worker_id,
        "worker_addr": worker_addr,
        "log_filename": "event_log_%s.csv" % (now('filename')),
        "date_created": now(),
        "version": version(),
    }

    # always check the src & dst volumes exist
    while source == None or not os.path.isdir(source):
        print "Source folder does not exist!"
        source = raw_input("Source folder(%s): " % (source)) or source
        source = strip_trailing_slash(source)


    while destination == None or source == destination or not os.path.isdir(destination):
        print "Desintation folder does not exist!"
        new_dest = raw_input("Desitination folder(%s): " % (destination)) or destination
        new_dest = strip_trailing_slash(new_dest)

        if source == new_dest:
            print "Desintation folder must be different to Source folder!"
            print "Source: %s" % source
            continue

        destination = new_dest

    # resolve relative paths to absolute paths
    if not re.search('^/', source):
        source = os.path.realpath(source)

    if not re.search('^/', destination):
        destination = os.path.realpath(destination)


    cls(3)
    print "Source folder: %s" % config('src')
    print "Destination folder: %s" % config('dst')

    log_file_name = config('log_filename')
    config_path = "%s%s%s" % (destination, slash(), config_filename)
    config_exists = os.path.isfile(config_path)


    if delete_config_file:
        config_exists = False

    # generate web monitor assets
    # requires the destination path and .mkproxy folder
    if config_exists and create_web_assets:
        create_assets(destination)
        sys.exit(0)

    if config_exists:
        config_dct.update(json.loads(open(config_path, 'r').read()))

        # update local references
        config('src', source)
        config('dst', destination)
        config('worker', worker_id)
        config('worker_addr', worker_addr)

        print "Config exists. Participate as worker thread \"%s\" (%s)" % (config('worker'), config('worker_addr'))

        # confirm rel path to src and dst
        log_file_name = config('log_filename')

    cls(2)
    print "Collect FFMPEG prores settings:"
    config('prores_encoder', get_input('Which prores encoder', 'string', ['prores_ks', 'prores', 'prores_aw'], config_exists))
    config('prores_profile', get_input('Which prores profile -- 0:Proxy, 1:LT, 2:SQ and 3:HQ', 'string', ['0', '1', '2', '3'], config_exists))
    config('prores_quality', get_input('Quality -- 0:high to 32:low', 'number', [15, 0, 32], config_exists))
    config('transcode', get_input('Transcode -- \"all\", \"no\" OR list', 'array', ['all', 'none'], config_exists))
    config('dimensions', get_input('Resize -- \"no\" OR (WIDTH)x(HEIGHT)', 'dimension', ['1920x1080', '1280x720', '1920x1080', '2560x1440', '3840x2160', '7680x4320'], config_exists))
    config('gig_limit', get_input('Skip large files -- 0 = No Gig limit', 'number', [20, 0, 999], config_exists))
    config('byte_limit', int(float(config('gig_limit'))*gigabyte))



    # sys.exit(0)


    if not config_exists:

        # create a config file for slave nodes
        cls(2)
        asset_folder = config_path.replace("config.json", '')
        print "Create NEW config file:\n", get_prefix(config_path)
        # create the asset folder
        if not os.path.isdir(asset_folder):
            print "Create folder:", asset_folder
            try:
                os.makedirs(asset_folder)
            except:
                msg = tsv("ERROR", "Can't asset folder", asset_folder)
                if not errors.count(msg):
                    errors.append(msg)
                    append_to_log(msg)
                sys.exit(0)


        # config_path = "%s%s%s" % (destination, slash(), get_prefix(config_filename))

        config_file = open(config_path, 'w')
        config_file.write(json.dumps(config_dct, indent=4))
        config_file.close()

        create_ffmpeg_files = True
        append_to_log(tsv("TYPE", "DESCRIPTION", "VALUE", "COMMENT"))
        append_to_log(tsv("INFO", "input", source))
        append_to_log(tsv("INFO", "output", destination))
        append_to_log(tsv("INFO", "encoder", config('prores_encoder')))
        append_to_log(tsv("INFO", "profile", config('prores_profile')))
        append_to_log(tsv("INFO", "quality", config('prores_quality')))
        append_to_log(tsv("INFO", "dimensions", config('dimensions')))
        append_to_log(tsv("INFO", "size limit", config('byte_limit'), sizeof_fmt(config('byte_limit'))))


    ignore_folders = get_ignored_folders()

    if create_ffmpeg_files:
        create_output_assets()
        present_warnings()
        if len(stack):
            cls(2)
            print "There are %d items ready to transcode." % (len(stack))
            if raw_input("Do you want to continue: (y/N) ") != 'y':
                sys.exit(0)

    create_proxy_footage()

